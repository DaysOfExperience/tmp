# 什么是缓存

缓存 (cache) 是计算机中的⼀个经典的概念. 在很多场景中都会涉及到.

**核心思路就是把⼀些常用的数据放到触手可及(访问速度更快)的地方, 方便随时读取.**

> 举个例⼦: 
>
> ⽐如我需要去⾼铁站坐⾼铁. 我们知道坐⾼铁是需要反复刷⾝份证的 (进⼊⾼铁站, 检票, 上⻋, 乘⻋过程中, 出站....). 正常来说, 我的⾝份证是放在<u>⽪箱⾥的(⽪箱的存储空间⼤, ⾜够能装)</u>. 但是每次刷⾝份证都需要开⼀次⽪箱找⾝份证, 就⾮常不⽅便. 
>
> 因此我就可以把⾝份证先放到⾐服⼝袋⾥. <u>⼝袋虽然空间⼩, 但是访问速度⽐⽪箱快很多</u>. 这样的话每次刷⾝份证我只需要从⼝袋⾥掏⾝份证就⾏了, 就不必开⽪箱了. 
>
> <u>此时 "⼝袋" 就是 "⽪箱" 的缓存</u>. **使用缓存能够大大提高访问效率.**

>  这⾥所说的 "触⼿可及" 是个相对的概念. 
>
>  我们知道, 对于硬件的访问速度来说, 通常情况下: CPU 寄存器 > 内存 > 硬盘 > ⽹络 
>
>  那么硬盘相对于⽹络是 "触⼿可及的", 就可以使⽤硬盘作为⽹络的缓存. (举个例子: 对于浏览器而言, 需要通过HTTP/HTTPS协议来与web服务器进行通信, HTTP作为一个超文本应用层协议, 可能会传输各种类型的数据, 而对于比如图片等体积较大且修改频率很低的数据而言, 通过网络传输的成本较高, 效率较低, 所以此时就可以用硬盘作为网络的缓存: 比如可以保存在浏览器本地, 也就是浏览器所在的主机的硬盘中, 这样后续再通过HTTP协议打开某个页面, 就可以直接访问硬盘中的图片数据, 不用再通过网络传输了~)
>  内存相对于硬盘是 "触⼿可及的", 就可以使⽤内存作为硬盘的缓存. (举个例子: Redis作为MySQL的缓存, Redis用内存存储数据, MySQL用磁盘存储数据, 访问内存/访问Redis的速度远大于访问磁盘/MySQL的速度)
>  CPU 寄存器相对于内存是 "触⼿可及的", 就可以使⽤ CPU 寄存器作为内存的缓存.
>
>  多问问题....

对于计算机硬件来说, 往往访问速度越快的设备, 存储空间越小, 成本越⾼.

缓存是更快, 但是空间上往往是不⾜的. 因此⼤部分的时候, 缓存只放⼀些热点数据 (访问频繁的数据), 就⾮常有⽤了.

关于 "⼆⼋定律" : 20% 的热点数据, 能够应对 80% 的访问场景. 

<u>**因此只需要把这少量的热点数据缓存起来, 就可以应对⼤多数场景, 从⽽在整体上有明显的性能提升.**</u>

# 使用 Redis 作为缓存

> redis最常用的场景   缓存 > 内存数据库 > 消息队列

在⼀个⽹站中, 我们经常会使⽤关系型数据库 (⽐如 MySQL) 来存储数据.

**关系型数据库虽然功能强大, 但是有⼀个很大的缺陷, 就是性能不高.** (换⾔之, 进⾏⼀次查询操作消耗的系统资源较多).

>  为什么说关系型数据库性能不⾼?
>
>  1. 数据库把数据存储在硬盘上, 硬盘的 IO 速度相比于redis的内存来说就很慢. 尤其是随机访问, 就更慢了. 
>  1. 如果查询不能命中索引, 就需要进⾏表的遍历, 这就会⼤⼤增加硬盘 IO 次数. （比如几条记录就是一次磁盘IO，是很正常的）
>  1. 关系型数据库对于 SQL 的执⾏会做⼀系列的解析, 校验, 优化⼯作. 
>  1. 如果是⼀些复杂查询, ⽐如联合查询, 需要进⾏笛卡尔积操作, 效率更是降低很多. 
>  1. ......
>
>  其中, 1, 2点是针对硬件来说的, 2, 3点是针对软件来说的.

<u>因为MySQL等数据库的效率低, 所以所能承载的并发量就有限, 如果访问数据库的并发量⽐较⾼, 对于数据库的压⼒是很⼤的, 很容易就会使数据库服务器宕机.</u>

> 为什么并发量⾼了就会宕机? 
>
> 服务器每次处理⼀个请求, 都是需要消耗⼀定的硬件资源的. 所谓的硬件资源包括不限于 CPU, 内存, 硬盘, ⽹络带宽...... 
>
> ⼀个服务器的硬件资源本⾝是有限的. ⼀个请求消耗⼀份资源, 请求多了, ⾃然把资源就耗尽了. 后续的请求没有资源可⽤, ⾃然就⽆法正确处理. 更严重的还会导致服务器程序的代码出现崩溃, 机器也容易出现故障.  所以本质就是因为资源有限, 资源耗尽了就容易出现问题, 比如最典型的内存资源.

**如何提高MySQL数据库能够承担的并发量呢?** 

核⼼思路主要是两个: 

- 开源: 引⼊更多的机器, 部署更多的数据库实例, 构成数据库集群. (主从复制, 分库分表等...) (MySQL也可以部署主从结构)
- 节流: **引入缓存: 使用缓存保存经常访问的热点数据, 后续查询数据时, 缓存中若已经存在, 则访问缓存即可, 从而降低直接访问数据库的请求数量.** (也就是redis因为是内存数据库, 访问速度较快, 所以所能支持的并发量也就高, 可以让redis存储20%的热点数据, 就可以支持80%的访问, 这样只有20%的访问会打到MySQL中, 利用缓存就支持了单独使用MySQL所不能承载的更高的并发量, MySQL并不需要负责全部的请求)

> 实际开发中, 这两种⽅案往往是会搭配使⽤的.

**Redis 就是一个用来作为数据库缓存的常见方案.**

> <u>Redis 访问速度⽐ MySQL 快很多. 或者说处理同⼀个访问请求, Redis 消耗的系统资源⽐ MySQL 少很多. 因此 Redis 能⽀持的并发量更⼤.</u>
>
> - Redis 数据存储在内存中, 访问内存⽐硬盘快很多. 
> - Redis 只是⽀持简单的 key-value 存储, 不涉及复杂查询的那么多限制规则.
>
> 这里其实就是简单说了一下为什么redis快... 重点讲解缓存

Redis就像⼀个 "护盾" ⼀样, 把 MySQL 给罩住了.

![image-20230914123448181](C:\Users\yangzilong\AppData\Roaming\Typora\typora-user-images\image-20230914123448181.png)

使用Redis存储少量的热点数据, 充当缓存的角色. MySQL作为数据库存储全量数据

- 客⼾端访问业务服务器, 发起查询请求. 
- 业务服务器先查询 Redis, 看想要的数据是否在 Redis 中存在. 
  - 如果已经在 Redis 中存在了, 就直接返回. 此时不必访问 MySQL 了. (Redis起作用了)
  - 如果在 Redis 中不存在, 再查询 MySQL. (这样的概率较小, 因为28原则)

按照上述讨论的 "⼆⼋定律" , 只需要在 Redis 中放 20% 的热点数据, 就可以使 80% 的请求不再真正查询数据库了. 

> 当然, 实践中究竟是 "⼆⼋", 还是 "⼀九", 还是 "三七", 这个情况可能会根据业务场景的不同, 存在差异. 但是⾄少绝⼤多数情况下, **<u>使⽤缓存都能够⼤⼤提升整体的访问效率, 降低数据库的压⼒.</u>**(注意, 说数据库就是MySQL这样的数据库, Redis的角色就是缓存, 分清楚一点)

 **注意! 缓存是用来加快 "读操作" 的速度的. 如果是 "写操作", 还是要老老实实写数据库, 缓存并不能提高写操作的性能.**

# 缓存的更新策略[重点]

接下来还有⼀个重要的问题, 到底数据库中的哪些数据才是缓存需要存储的 "热点数据" 呢?

## 1.定期更新

每隔⼀定的周期(⽐如⼀天/⼀周/⼀个⽉), 对于访问的数据频次进⾏统计. 挑选出访问频次最⾼的前 N% 的数据.

具体来说: 把访问的数据通过日志的方式记录下来, 一定周期对这个日志的内容按照频率排降序(这里的数据量可能很大), 然后取出前N%(如20%)的数据, 这些数据就是热点数据, 也就是Redis需要存储/缓存的数据.

>  以搜索引擎为例. 
>
> ⽤⼾在搜索引擎中会输⼊⼀个 "查询词", 有些词是属于⾼频的, ⼤家都爱搜(鲜花, 蛋糕, 同城交友, 不孕不育...). 有些词就属于低频的, ⼤家很少搜. 
>
> 搜索引擎的服务器会把哪个⽤⼾什么时间搜了啥词, 都通过⽇志的⽅式记录的明明⽩⽩. 每隔⼀段时间对这期间的搜索结果进⾏统计 (⽇志的数量可能⾮常巨⼤, 这个统计的过程可能需要使⽤ hadoop 或者 spark 等⽅式完成). 从⽽就可以得到 "⾼频词表" . 可以用Redis来存储这些热点查询词涉及到的搜索结果~

优点: 实现起来比较简单, 过程更可控, 方便排查问题

缺点: **这种做法实时性较低**. 对于⼀些突然情况应对的并不好.
(比如某半天内, 突然发生了一个大新闻, 然后这个新闻的有关数据就是热点搜索数据, 但是因为定期更新Redis缓存数据的周期是一天, 那么就会导致新闻发生之后的这段时间内的实际的热点数据不在缓存中, 就会大量访问数据库, 很可能给数据库造成较大压力)

> ⽐如春节期间, "春晚" 这样的词就会成为⾮常⾼频的词. ⽽平时则很少会有⼈搜索 "春晚".

## 2.实时更新

⽤⼾每次查询: 

- 如果在 Redis 查到了, 就直接返回. 
- **如果 Redis 中不存在, 就从数据库查, 把查到的结果同时也写入 Redis.** 

这样一来, Redis中存储的数据, 都可以认为是"最近"的热点数据, <u>相比与定期生成而言, 热点数据的实时性更高一些~</u>

但是随着这样一直进行, Redis中存储的数据会越来越多, 会到达存储容量上限(不一定是机器内存上限, Redis也可以设定存储的数据容量上限: maxmemory参数设定~)

如果缓存已经满了(达到上限), 就必须触发**缓存淘汰策略(内存淘汰策略)**: 把⼀些 "相对不那么热⻔" 的数据淘汰掉. 

### 内存淘汰策略[重点]

> 内存淘汰策略 / Redis内存淘汰机制 / 缓存淘汰策略 / 缓存淘汰机制 
>
> 实时更新 / 实时生成 所必然引发的一个问题: 内存达到上限的解决方法: 内存淘汰机制

通⽤的淘汰策略主要有以下⼏种:

> 下列策略并⾮局限于 Redis, 其他缓存也可以按这些策略展开.

1. **FIFO** (First In First Out) 先进先出

   **把缓存中存在时间最久的 (也就是先来的数据) 淘汰掉**.  

2. **LRU** (Least Recently Used): **淘汰最长时间未访问的数据**

   记录每个 key 的最近访问时间. 把最近访问时间与现在时间差值最长的 key 淘汰掉.

3. **LFU** (Least Frequently Used): **淘汰缓存中访问次数最少的数据(最不频繁的)**

   记录每个 key 最近⼀段时间内的访问次数. 把访问次数最少的淘汰掉.   (相对来说最靠谱, 所淘汰的访问次数最少的数据, 最符合缓存中最没有价值的数据, 这样一来, 缓存中存储的数据都是最"热点"的数据)

4. **Random** 随机淘汰

   从所有的 key 中抽取幸运⼉, 随机淘汰掉.  (感觉真的很不合理..)

> 理解上述⼏种淘汰策略: 想象你是个皇帝, 有后宫佳丽三千. 虽然你是 "真⻰天⼦", 但是经常宠幸的妃⼦也就那么寥寥数 
>
> ⼈(精⼒有限). 
>
> 后宫佳丽三千, 相当于数据库中的全量数据. 经常宠幸的妃⼦相当于热点数据, 是放在缓存中的. 
>
> 今年选秀的⼀批新的⼩主, 其中有⼀个被你看上了. 宠信新⼈, ⾃然就需要有旧⼈被冷落. 到底谁是要被冷落的⼈呢? 
>
> FIFO: 皇后是最先受宠的. 现在已经年⽼⾊衰了. 皇后失宠. 
>
> LRU: 统计最近宠幸时间. 皇后(⼀周前), 熹妃(昨天), 安答应(两周前), 华妃(⼀个⽉前). 华妃失宠. 
>
> LFU: 统计最近⼀个⽉的宠幸次数, 皇后(3次), 熹妃(15次), 安答应(1次), 华妃(10次). 安答应 失宠.
>
> Random: 随机挑⼀个妃⼦失宠.

Redis有个配置项可以指定Redis的内存淘汰策略

Redis 内置的可选的淘汰策略如下:

- `volatile-lru` : 当内存不⾜以容纳新写⼊数据时，<u>从设置了过期时间的key中使⽤LRU（最近最少使⽤）算法进⾏淘汰</u> 
- `allkeys-lru` : 当内存不⾜以容纳新写⼊数据时，<u>从所有key中使⽤LRU（最近最少使⽤）算法进⾏淘汰.</u> 
- `volatile-lfu` : 4.0版本新增，当内存不⾜以容纳新写⼊数据时，<u>在过期的key中，使⽤LFU算法进⾏删除key.</u>
- `allkeys-lfu` : 4.0版本新增，当内存不⾜以容纳新写⼊数据时，<u>从所有key中使⽤LFU算法进⾏淘汰.</u> 
- `volatile-random` : 当内存不⾜以容纳新写⼊数据时，<u>从设置了过期时间的key中，随机淘汰数据.</u> 
- `allkeys-random` : 当内存不⾜以容纳新写⼊数据时，<u>从所有key中随机淘汰数据.</u> 
- `volatile-ttl` : <u>在设置了过期时间的key中，根据过期时间进⾏淘汰，越早过期的优先被淘汰.</u> (相当于FIFO, 只不过是局限于设定了过期的key) 
- `noeviction` : 默认策略，当内存不⾜以容纳新写⼊数据时，新写⼊操作会报错.  (不适合Redis的实时更新策略)

整体来说 Redis 提供的策略和我们上述介绍的通⽤策略是基本⼀致的. 只不过 Redis 这⾥会针对 "过期 key" 和 "全部 key" 做分别处理.

# 缓存预热, 缓存穿透, 缓存雪崩 和 缓存击穿[重点]

## 关于缓存预热 (Cache preheating)

缓存中的数据: 1. 定期更新(定期生成), 则不涉及预热    2. 实时更新(实时生成), 则Redis服务器在首次接入时, 是没有数据的, 存储的缓存数据是逐步增长的, 是需要在访问Redis不存在, 然后访问MySQL之后再将这个不存在的数据存入Redis中作为缓存数据.

<u>那么, 在Redis首次接入的一段时间内, 或者刚接入时, Redis中存储的缓存数据很少 / 没有, 几乎所有的请求都会访问到MySQL, 所以MySQL的压力就会很大, 容易将MySQL搞崩.</u> 当然随着时间推移, Redis存储的数据越来越多, MySQL的压力就会越来越小. <u>但是需要防备和处理的是Redis刚接入的这段时间内.  (问题)</u>

**解决方法: 缓存预热, 就是用来解决上述问题的.**

也就是结合定期生成和实时生成, 先进行一次定期生成 / 定期更新, 通过离线的方式, 先统计一次热点数据, 导入到Redis中, 此时将Redis接入到分布式系统中, 就可以立即为MySQL数据库分担较大的压力, 之后再根据实时更新, 对Redis存储的缓存数据进行淘汰

---

**什么是缓存预热**

使⽤ Redis 作为 MySQL 的缓存的时候, 当 Redis 刚刚启动, 或者 Redis ⼤批 key 失效之后, 此时由于 Redis ⾃⾝相当于是空着的, 没啥缓存数据, **那么 MySQL 就会被大量请求访问到, 从而造成较大的压力.**   (这个是问题)

**解决方法: 缓存预热**

因此就需要提前把热点数据准备好(离线进行一次定期生成即可), 直接写⼊到 Redis 中. 使 Redis 可以尽快为 MySQL 撑起保护伞.

热点数据可以基于之前介绍的统计的⽅式⽣成即可. 这份热点数据不⼀定⾮得那么 "准确", 只要能帮助 MySQL 抵挡⼤部分请求即可. 随着程序运⾏的推移, 缓存的热点数据会逐渐⾃动调整, 来更适应当前情况.

## 关于缓存穿透 (Cache penetration)

**什么是缓存穿透?** 

**访问的 key 在 Redis 和 数据库中都不存在. 此时这样的 key 不会被放到缓存上, 后续如果再访问该 key, 依然会访问到数据库. **
**<u>如果这样的数据很多, 且反复查询, 就会给数据库造成较大压力. 这种情况称为 缓存穿透.</u>**

**缓存穿透的产生原因** 

- <u>业务设计不合理</u>: ⽐如缺少必要的参数校验环节, 导致⾮法的 key 也被进行查询了.  (典型) 

- <u>开发/运维误操作, 不⼩⼼把部分数据从数据库上误删了</u>. (没那么典型, 但是表现出的现象也是缓存穿透, 也就是Redis和MySQL, 缓存和数据库中都访问不到~) 

- <u>⿊客恶意攻击</u> (较少见)

**如何解决缓存穿透**

- <u>针对要查询的参数进⾏严格的合法性校验</u>. ⽐如要查询的 key 是⽤⼾的⼿机号, 那么就需要校验当前 key 是否满⾜⼀个合法的⼿机号的格式. <u>直接在业务层拒绝不合法的查询, 就不会访问缓存和数据库了</u>
- <u>针对数据库上也不存在的 key , 也存储/缓存到 Redis 中, ⽐如 value 就随便设成⼀个 "". 避免后续频繁访问数据库.</u> 业务层获取到这个空串之后, 也能判断到这个请求的key是不存在的~
- <u>使⽤布隆过滤器先判定 key 是否存在, 再真正查询.</u> (使用布隆过滤器存储所有的key)

> 关于布隆过滤器, 简单的说, 布隆过滤器是结合了 hash + bitmap 的思想, 能够⽤较少的空间开销, 较小的时间开销, 判定某个元素是否 存在(某个key 是否存在)

## 关于缓存雪崩 (Cache avalanche)

**什么是缓存雪崩** 

<u>**短时间内大量的 key 在缓存上失效, 导致数据库压力骤增**</u> (甚⾄直接宕机)

> 本来 Redis 是 MySQL 的⼀个护盾, 帮 MySQL 抵挡了很多外部的压⼒. ⼀旦护盾突然失效了, MySQL ⾃⾝承担的压⼒骤增, 就可能直接崩溃.

**可能造成缓存雪崩的原因** : ⼤规模 key 失效, 可能性主要有两种: 

- <u>Redis 挂了.</u> 

- <u>Redis 上的⼤量的 key 同时过期.</u> 

  为啥会出现⼤量的 key 同时过期? 这种很可能是短时间内在 Redis 上缓存了⼤量的 key, 并且设定了相同的过期时间.(有关设定过期时间: 有时候给Redis中添加key作为缓存数据时, 有时候为了考虑时效性, 会设定过期时间, 这个和Redis的内存淘汰机制, 是配合使用的, 并不冲突: 本身LRU LFU等淘汰机制有时候也会针对设定了过期时间的key进行淘汰)

**如何解决缓存雪崩?**

- 针对第一点: 提高Redis集群的可用性即可: <u>部署⾼可⽤的 Redis 集群, 并且完善监控报警体系.</u>
  比如, 哨兵.. 集群.. 

- 针对第二点: <u>不给 key 设置过期时间 或者 设置过期时间的时候添加随机时间因⼦(避免短时间内大量key同时过期)</u>

## 关于缓存击穿 (Cache breakdown)

> 此处把 breakdown 翻译成 "击穿" , 个⼈以为并⾮是⼀个好的选择. 容易和缓存穿透混淆.  翻译成 "瘫痪" 或者 "崩溃" 也许更合适⼀些.

**什么是缓存击穿?**

相当于缓存雪崩(大量key短时间内 / 同时失效) 的特殊情况: <u>针对热点 key , 突然过期了, 导致⼤量的请求直接访问到数据库上</u>, 甚⾄引起数据库宕机.   (其实就是因为 Redis中的那些"热点"key, 影响更大一些, 因为请求访问次数/频率更高嘛)

**如何解决缓存击穿** 

- <u>基于统计的⽅式发现热点 key, 并设置永不过期.</u> (往往需要对服务器结构做出较大调整)

- 进⾏必要的服务降级(减少服务器的功能). 例如访问数据库的时候使⽤分布式锁, 限制同时请求数据库的并发数.  

也就是说, 第一点是避免热点key过期. 第二点是在热点key过期之后, 避免大量的访问打到数据库中, 造成较大压力.

第一点是避免出现缓存击穿. 第二点是出现缓存击穿现象后, 避免给数据库造成较大压力. 比如可以减少服务器提供的服务, 或者直接通过分布式锁, 减小服务器集群访问数据库的频率, 减小数据库压力~



---

## 总结

这四个的本质其实都是, 因为某种原因, 造成数据库承担较大压力, 而因为数据库如MySQL速度慢, 能承受的并发量不高, 面对高并发场景, 就容易挂.

缓存预热: Redis缓存刚接入分布式系统时, 存储的缓存数据少, 给数据库造成较大压力

缓存穿透: 大量 / 反复的查询的数据不在缓存中, 也不在数据库中, 给数据库造成较大压力

缓存雪崩: 大量缓存数据key, 在Redis中短时间/同时过期, 给数据库造成较大压力

缓存击穿: 热点key过期, 给数据库造成较大压力

可以看看共同点，多思考思考，多总结总结。