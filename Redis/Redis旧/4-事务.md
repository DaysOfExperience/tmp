# Redis事务

事务的初心其实就是事务的原子性，也就是可以让一组操作打包在一起，一起执行。

Redis 的事务 vs MySQL 事务：

- **弱化的原子性**: 

Redis的事务的原子性：将多个操作打包在一起，要么全部执行，要么全部不执行。
MySQL事务的原子性：将多个操作打包在一起，要么全部执行成功，要么全都不执行。

**主要原因是Redis的事务没有回滚机制**，也就是如果事务中的某一个操作执行失败，那么也就失败了，所以并不保证全部执行成功。而MySQL事务有回滚机制，也就是如果某个操作失败了，那么就自动回滚，也就是全都不执行。

**所以，Redis的事务到底有没有原子性，要看事务原子性的定义，是否要求全部执行成功~**，或者我们可以称之为弱化的原子性就很棒~
相当于是MySQL提高了事务的原子性的门槛了。

> redis 没有 "回滚机制". 只能做到这些操作 "批量执⾏". 不能做到 "⼀个失败就恢复到初始状态".

- **不具备⼀致性**: Redis没有约束，也没有回滚.事务的执行过程中若某个操作失败，则会出现不一致的情况。MySQL 的⼀致性体现的是运⾏事务前和运⾏后 , 结果都是合理有效的, 不会出现中间⾮法状态.（结果符合预期~）
- **不具有持久性**: (mysql的事务的持久性指的是只要事务执行成功, 则就是持久化的)redis是一个内存数据库，数据是保存在内存中的. 是否开启持久化, 是redis-server ⾃⼰的事情, 和事务⽆关.（redis的持久化机制和事务没关系）
- **不涉及隔离性**: Redis服务端是一个单Reactor单线程模型的服务器程序，不涉及隔离，也就没有隔离级别, **因为根本不会并发执⾏事务 (redis单线程处理请求)** .所有的请求/事务，都是串型执行的~

Redis 事务的实现：

本质上是在每个客户端上搞了⼀个 "事务队列". 每次客⼾端在事务中进⾏⼀个操作, 都会把命令先发给服务器, 并放到 "事务队列" 中(并不会⽴即执⾏)，而是会在真正收到 EXEC 命令之后, 才真正执⾏队列中的所有操作.也就是遇到"执行事务"的命令时，才会把队列中的这些指令按照顺序依次执行。**（redis的主线程完成，这个过程中不会穿插执行其他事务的命令）**

> **因此, Redis 的事务的功能相⽐于 MySQL 来说, 是弱化很多的. 只能保证事务中的这⼏个操作是 "连续 的", 不会被别的客⼾端 "加塞", 仅此⽽已.**

---

为什么Redis的事务不做成和MySQL一样完善呢？

因为MySQL的事务的功能虽然强大，但是这一定意味着更大的时间和空间开销。而Redis只有这样简单的事务才能发挥它快的优势~

# Redis事务的使用场景

因为本身功能就比较简单，所以，使用场景也很好理解的。

简单来说：卖票场景中，如果两个卖票逻辑中的指令穿插执行，则很有可能出现超卖的情况，所以，<u>就可以把整个卖票的关键逻辑打包成事务。</u>

在多线程场景中，通过加锁来避免"插队"，实现线程安全。Redis直接使用事务即可，道理是一样的。

因为很好理解，所以就不具体细说了。

# 事务操作

```cpp
MULTI   开启⼀个事务.
EXEC    真正执⾏事务.
DISCARD 放弃当前事务. 此时直接清空事务队列. 之前的操作都不会真正执⾏到.

在MULTI之后的每次命令＂执行＂操作
每次添加⼀个操作, 都会提⽰ "QUEUED", 说明命令已经进⼊客户端的队列了.
真正执⾏ EXEC 的时候, 客⼾端才会真正把事务队列中的操作发送给服务器并依次执行.
    
    
    ---
127.0.0.1:6379> multi
OK
127.0.0.1:6379> lpush ls sadsa aaa zzz sds
QUEUED
127.0.0.1:6379> exec
1) (integer) 4
127.0.0.1:6379> multi 
OK
127.0.0.1:6379> get fuck
QUEUED
127.0.0.1:6379> exec
1) "you"
127.0.0.1:6379> multi 
OK
127.0.0.1:6379> get fuck
QUEUED
127.0.0.1:6379> get fuck
QUEUED
127.0.0.1:6379> get fuck
QUEUED
127.0.0.1:6379> get fuck
QUEUED
127.0.0.1:6379> get fuck
QUEUED
127.0.0.1:6379> get fuck
QUEUED
127.0.0.1:6379> exec
1) "you"
2) "you"
3) "you"
4) "you"
5) "you"
6) "you"
```

```cpp
WATCH    在执⾏事务的过程中, 如果某个事务中修改的值, 被别的客户端修改了, 此时就容易出现数据不⼀致的问题.
    	 watch用于监控某个key是否在事务的multi -> exec的过程中被其他客户端改变。若改变，则事务的所有操作都不执行~
UNWATCH  取消对 key 的监控.
```

![image-20230904204227380](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230904204227380.png)

简单来说就是对于客户端2来说，对于key的值可能会产生歧义。所以watch用于处理这样的类似场景。(注意，set key 222操作实际上的执行是比set key 333晚的，因为exec时才会真正让服务端执行这个事务中的命令)

watch 命令就是⽤来解决这个问题的. watch 在该客⼾端上监控⼀组具体的 key.

- 当开启事务的时候, 如果对 watch 的 key 进⾏修改, 就会记录当前 key 的 "版本号". (版本号是个简单的整数, 每次修改都会使版本变⼤. 服务器来维护每个 key 的版本号情况)
- 在真正提交事务的时候, **如果发现当前服务器上的 key 的版本号已经超过了事务开始时(mutil)的版本号, 就会让事务执⾏失败.** **(事务中的所有操作都不执⾏).** 因为这意味着multi 和 exec之间, 有其他的客户端修改了这个key的值

---

**watch的实现思想，是一个乐观锁。**乐观锁：认为接下来锁冲突概率较小。悲观锁：认为接下来的锁冲突概率较低。C++/Linux中涉及的锁mutex/std::mutex都是悲观锁。

<u>乐观锁/悲观锁指的是某个锁的特性，而不是具体的锁。</u>

你所认为的接下来冲突概率的大小和接下来的处理方式是有关系的，比如这里，在mutil之后，我认为冲突概率不高，所以客户端2的set可以"并发"执行，但是如果真的出现了冲突，我再以事务所有操作都不执行的方式处理这个冲突。而不是悲观的认为接下来概率高，那么可能处理方式就是加锁从而不让客户端2的set在mutil和exec之间执行了。

---

**watch的实现原理**

watch一个key，就给这个key分配一个版本号，版本号可以理解为一个整数，每次修改时都会使版本号增加。这样一来就很简单了。

只需要在exec时，进行判断，判断watch的key在mutil之前的版本号和此时的版本号是否一致，若一致，则在mutil -> exec过程中没有被其他客户端修改。若不一致。则说明其他客户端进行了修改。则丢弃事务中的全部操作。exec返回nil

所以，watch必须搭配事务使用，且必须在mutil之前执行。watch本质是给exec添加了一个”执行条件“
