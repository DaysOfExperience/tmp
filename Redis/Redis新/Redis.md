# Redis基本原理

### 数据结构

[Redis 常见数据类型和应用场景 | 小林coding](https://xiaolincoding.com/redis/data_struct/command.html)

每种数据对象都各自的应用场景，你能说出它们各自的应用场景吗？ 面试过程中，这个问题也很常被问到，又比如会举例一个应用场景来问你，让你说使用哪种 Redis 数据类型来实现。

string内部实现

string应用场景 共享 Session 信息

List 应用场景

Hash 应用场景

Set 应用场景

Zset 应用场景

#### [Redis 数据结构 | 小林coding](https://xiaolincoding.com/redis/data_struct/data_struct.html)

数据类型(对象) vs 数据结构

<img src="https://cdn.xiaolincoding.com//mysql/other/9fa26a74965efbf0f56b707a03bb9b7f-20230309232518487.png" alt="img" style="zoom:67%;" />



双向链表 -> quicklist    压缩列表 -> listpack

**共有 9 种数据结构：SDS、双向链表、压缩列表、哈希表、跳表、整数集合、quicklist、listpack。**



##### 键值对数据库Redis是如何实现的   

todo

##### SDS

- C 语言字符串的缺陷 ez
- SDS
  四个成员变量









### 线程模型

其实很少, 就是那两三个问题, 但是是和网络IO相关联的, 先这样吧

---

为什么单线程能这么快?
需要理解Redis多线程是解决什么问题
分清楚命令处理与IO处理，进—步理解Redis架构

[03 高性能IO模型：为什么单线程Redis能那么快？ (lianglianglee.com)](https://learn.lianglianglee.com/专栏/Redis 核心技术与实战/03  高性能IO模型：为什么单线程Redis能那么快？.md)

> 其实就开始的一点点, 第四点讲的是网络IO, 多路复用, 好久没学, 忘了... 2min

- 首先，我要和你厘清一个事实: Redis的单线程仅限于...

- Redis 为什么用单线程: 多线程的开销(这里要自己能说出来, 1. 理解. 2. 讲述)

  > **多线程编程模式面临的共享资源的并发访问控制问题**。
  >
  > 即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加。
  >
  > 而且，采用多线程开发一般会引入同步原语来保护共享资源的并发访问，这也会降低系统代码的易调试性和可维护性。为了避免这些问题，Redis 直接采用了单线程模式。

- 单线程Redis为什么那么快?

  > 1. Redis 的大部分操作在内存上完成
  > 2. 采用了高效的数据结构，例如哈希表和跳表
  > 3. 单线程模型可以 **避免了多线程之间的竞争**
  > 4. 网络 IO采用了多路复用机制

- 基本 IO 模型与阻塞点  从这里开始, 到小结之前, 一直讲多路复用?? 

[面试官：你确定 Redis 是单线程的进程吗？-有了 (zhipin.com)](https://youle.zhipin.com/articles/750c0e1e89e8d548qxB709-6EA~~.html)

> 很相似, 但是比上面那个好(Redis6.0前后都讲清楚了. 重点还是理解加自己讲出来



[Redis 6.0 新特性：带你 100% 掌握多线程模型 - todo(2月底没看)](https://juejin.cn/post/6989109527886954527)

未来可以再进一步学习的(有时间, 有精力, 能做到的话) 6.0的其它特性

> 挺不错的, 结合起来吧, 大致的重点都是一样的

> Redis 6.0 之前为什么不使用多线程？
>
>  Redis 6.0 为啥要引入多线程呀？
>

### 缓存过期删除与缓存内存淘汰

ez, 但是不确定目前这点够不够, 结合题库吧

> 过期淘汰算法  热点问题
>
> 过期删除: 因为Redis支持给键值对设置过期时间
>
> 内存淘汰: 因为Redis是内存缓存, 可能会满, 满了需要清除内存(可以不清除)

---

[Redis 过期删除策略和内存淘汰策略有什么区别？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/redis/module/strategy.html)

> 简单易懂

- Redis 对 key 设置过期时间的一些基本使用和说明

- 过期删除策略有哪些? 定时 惰性 定期

- Redis的过期删除策略? 惰性+定期(详细)

  > 惰性: Redis 在访问或者修改 key 之前, 检查 key 是否过期
  >
  > 定期: 详细, 具体看

- Redis内存淘汰有哪些策略? (有关LRU & LFU)

- LRU算法说明, Redis的近似LRU, 但是LRU有缓存污染的问题(LRU是按时间而不是频率, 有些数据只读一次, 你却只按时间, 污染内存)

- Redis如何实现LRU&LFU  LRU很简单 LFU就是先衰减, 再增加(这个表示访问频次的这个字段)

  > LFU解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题. 

### 持久化

自己写的那个质量还是高, 再稍微结合一下这两个文章就无敌了

> AOF RDB考察的重点
>
> 清楚他们的优缺点

---

[AOF 持久化是怎么实现的？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/redis/storage/aof.html)

- AOF机制: 将写命令以文本的形式记录在磁盘文件中, 以达到持久化的目的

- 简单分析, 引出 `AOF 日志写回硬盘的时机` 这个话题

- AOF写回硬盘的过程, 以及三种策略Always, Everysec, No(**三种策略实际上控制的就是将AOF日志文件的内核缓冲区写入磁盘的频率**, 也就是fsync函数的调用频率)

  > 三种策略, 一种数据的持久化最好, 安全性最高, 性能最差, 一种性能最好, 数据安全性最差. Everysec是折中
  >
  > 性能和数据的可靠性不能兼顾, 要可靠就要以性能为代价来换取

- AOF重写机制(父子进程, 写时拷贝, AOF重写缓冲区)
  (这里写的有点啰嗦, 其实我他妈早学会了, 只是忘了, 理解)

[RDB 快照是怎么实现的？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/redis/storage/rdb.html)

> 少, 容易理解

- RDB的介绍 & 写时拷贝 (重点是优缺点)

- 混合持久化 `aof-use-rdb-preamble yes`  混合持久化工作在 **AOF 日志重写过程**。  (这里写的简单明了)

  > 当开启了混合持久化时，在 AOF 重写日志时，`fork` 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，

> bgsave和AOF重写都是以fork创建子进程的形式进行的, 但是rdb本身就是全量且粗略的持久化, 所以bgsave期间的写命令造成的父子进程数据不一致不会处理. 而AOF就是细致的持久化, 子进程重写期间的写命令会写入到重写缓冲区, 最终会加入到新的AOF文件中

---

[Redis持久化RDB和AOF优缺点是什么，怎么实现的？我应该用哪一个？ - 架构师技术栈 - SegmentFault 思否](https://segmentfault.com/a/1190000013958342)

偏向于总结优缺点, 有时间就看一下

### 事务

[31 事务机制：Redis能实现ACID属性吗？ (lianglianglee.com)](https://learn.lianglianglee.com/专栏/Redis 核心技术与实战/31  事务机制：Redis能实现ACID属性吗？.md)

todo  还可以

# Redis高可用



# Redis应用场景

### 缓存异常问题

缓存击穿 缓存雪崩 缓存穿透的解决方案  经常问?

---

雪崩: 1. 大量缓存数据同时过期 2. Redis故障宕机

击穿: 热点数据过期

穿透: 缓存和数据库都不存在这个数据

> 缓存雪崩  1. 大量数据同时过期    **给这些数据的过期时间加上一个随机数** 均匀设置过期时间 2. 互斥锁(如果key不一样, 也互斥吗? 应该是的)   3. 后台更新缓存 没看懂= =  2.   Redis 故障宕机     可以,  *1. 服务熔断或请求限流机制* *2. 构建 Redis 缓存高可靠集群*   
> 
>缓存击穿如何解决?   互斥锁方案  2. .... 没法说啊    |   singlelight?????
> 
>缓存穿透如何解决?  非法请求的限制  缓存空值或者默认值   使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。  |     回写特殊值, 布隆过滤器
> 

[什么是缓存雪崩、击穿、穿透？](https://xiaolincoding.com/redis/cluster/cache_problem.html)

- 三个问题 + 三个问题的解决方法

> 缓存雪崩.大量数据同时过期  1. 过期时间随机化 2. 构建缓存时加互斥锁(???)  3. 后台更新缓存(?????????)
>
> 缓存雪崩.Redis故障宕机 1. 服务熔断或请求限流机制(!!!)   2. 构建 Redis 缓存高可靠集群
>
> 缓存击穿和雪崩很像, 是雪崩的一个子集
>
> 缓存穿透  1. 非法请求的限制 2. 缓存空值或者默认值 3. 使用布隆过滤器

[04 缓存失效、穿透和雪崩问题怎么处理？ (lianglianglee.com)](https://learn.lianglianglee.com/专栏/300分钟吃透分布式缓存-完/04 缓存失效、穿透和雪崩问题怎么处理？.md)

> 讲的更容易理解, 更结合实际, 更程序员化

- 缓存雪崩.大量同时过期  随机的过期时间

- 缓存穿透 一致, 解决1. 若穿透, 则设定特殊值到cache中, 2. 布隆过滤器   (更细一些

- 这里又讲了一个缓存雪崩 奇怪没看

[14 缓存策略：面试中如何回答缓存穿透、雪崩等问题？ (lianglianglee.com)](https://learn.lianglianglee.com/专栏/架构设计面试精讲/14  缓存策略：面试中如何回答缓存穿透、雪崩等问题？.md)

> 没啥不同的, 除了第二个都一样, 重点是自己理解+能清楚的讲述出来

缓存穿透(不用看)  缓存并发(setnx)(热点数据)    缓存雪崩(不用...)

附加的没看, 不懂

[17 如何应对 Redis 缓存穿透、击穿和雪崩？](https://learn.lianglianglee.com/专栏/说透性能测试/17  如何应对 Redis 缓存穿透、击穿和雪崩？.md)

> 不用看, 不细不清除
>
> 最后讲的才是雪崩 击穿 穿透 简短明了  其他部分讲了Redis的其他几个特性, 没看

---



> [缓存问题：怎么解决缓存穿透、击穿和雪崩问题？ | JUST DO IT (leeshengis.com)](https://leeshengis.com/archives/698514)
>
> 这个质量最高 (其实核心就是如何解决这三个问题呗~)
>
> 牛逼, 这个文章     牛逼, 真的
>
> >缓存穿透的解决方案
> >
> >缓存击穿的解决方案  (**singleflight再看一下**)
> >
> >缓存雪崩的解决方案
> >
> >**限流再看一下**
> >
> >**最后的亮点方案没理解**
> >
> >重点是解决方案, 比如面试问你, Redis里面缓存可能出现的异常情况, 以及如何解决?
>
> > 大体来说差别不是很大... 限流和异地有点新了, 多学学 singleflight再看看
>
> > *
> >
> > 可以认为缓存击穿是缓存雪崩的一个子集
> >
> > 这个问题之所以常见，是因为你在使用缓存的过程中一不小心就会遇到它们。
> >
> > 因此，如果请求的数据并不是什么热点数据，那么击穿也没有什么问题，它就是普通的缓存未命中而已。
> >
> > 缓存穿透是因为数据本身不存在而引起的，所以我们就要想办法在确认数据不存在之后，避免下一次查询再次落到数据库上。这有两种解决思路。
> >
> > 缺点

### 缓存一致性问题

你的项目中redis和mysql的缓存一致性是如何保证的?

![image-20250301212422593](C:\Users\yangzilong\Desktop\markdown\CS\Redis\Redis新\image-20250301212422593.png)

---

[数据库和缓存如何保证一致性？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#数据库和缓存如何保证一致性)

> 为什么有一致性问题? 因为更新数据的时候, 该怎么更新?
>
> 最终就是, 先更新数据库, 再删除缓存, 外加一个缓存过期时间, 其余的有更新并发问题或者读写并发问题

- 先更数据库, 后更缓存 或者反着来, 在更新请求并发更新同一个数据时都可能会出现数据库和缓存数据不一致的问题, 也就是并发问题

- Cache Aside策略(旁路缓存策略, 名字不重要), 写数据时, 采用更新数据库而删除缓存的方式, 读正常读

- 写数据时先删缓存, 后更新数据库, 读写并发时还是会有数据库和缓存数据不一致的问题

- 写数据时先更新数据库, 后删缓存可以保证数据一致性(外加一个过期时间)

  > 这里只要是删缓存的策略, 更新请求并发时是不会造成数据不一致的, 因为这里根本不会写缓存

- 隐患: 删除缓存的这个操作可能失败, 导致缓存中数据可能是旧数据, 而因为有过期时间, 所以只会造成短时间的数据不一致
  消息队列来解决?  跳过了.. 不会



> 另外, 若业务对缓存命中率有很高的要求, 



[认识 MySQL 和 Redis 的数据一致性问题 (lianglianglee.com)](https://learn.lianglianglee.com/文章/认识 MySQL 和 Redis 的数据一致性问题.md)

- 很严谨地定义数据的一致性(缓存与数据库)

[大厂都是怎么做 MySQLtoRedis 同步的? | MRCODE-BOOK (zq99299.github.io)](https://zq99299.github.io/note-book/back-end-storage/03/03.html#缓存穿透-超大规模系统的不能承受之痛)

[34｜缓存一致性问题：高并发服务如何保证缓存一致性？ | 车斌的技术博客](https://chebin.tech/2023/11/09/34｜缓存一致性问题：高并发服务如何保证缓存一致性？/)

绷不住了, 日后有缘再见

### 分布式锁

怎么用redis实现分布式锁?(setnx)
redis分布式锁单机实例挂了怎么办?(redlock)
怎么用redis实现可重复的分布式锁?(了解redisson是怎么实现可重复锁的)
有时候面试会考察你对分布式锁方案的了解，除了redis，还了解过哪些分布式锁的方案，可以提一下mysql和zk实现分布式锁的方案。

---

[30 如何使用Redis实现分布式锁？ (lianglianglee.com)](https://learn.lianglianglee.com/专栏/Redis 核心技术与实战/30  如何使用Redis实现分布式锁？.md)

> 简单且清晰, 快点看

- 对比单机上的锁和分布式锁(其实很简单). 实现分布式锁的两个要求1. 锁操作的原子性 2. 共享存储系统的可靠性(锁的可靠性)

  > 但是，和线程在单机上操作锁不同的是，在分布式场景下，**锁变量需要由一个共享存储系统来维护**，只有这样，多个客户端才可以通过访问共享存储系统来访问锁变量。相应的，加锁和释放锁的操作就变成了读取、判断和设置共享存储系统中的锁变量值。

- 基于单个 Redis 节点实现分布式锁

  > 问题1: 若持有锁的客户端异常不释放锁, 一直占用怎么办? 答: 给锁变量设定一个过期时间
  > 问题2: 误释放(B客户端释放了A持有的锁) 可以让每个客户端给锁变量设置一个唯一值，这里的唯一值就可以用来标识当前操作的客户端
  >
  > 最终: 加锁: 
  >
  > ```
  > // 加锁, unique_value作为客户端唯一性的标识
  > SET lock_key unique_value NX PX 10000
  > ```
  >
  > 释放锁: Lua脚本
  >
  > ```
  > //释放锁 比较unique_value是否相等，避免误释放
  > if redis.call("get",KEYS[1]) == ARGV[1] then
  >     return redis.call("del",KEYS[1])
  > else
  >     return 0
  > end
  > ```
  >
  > 在释放锁操作中，我们使用了 Lua 脚本，这是因为，释放锁操作的逻辑也包含了读取锁变量、判断值、删除锁变量的多个操作，而 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。

-  基于多个 Redis 节点实现高可靠的分布式锁: 分布式锁算法 Redlock  Redlock 算法的实现需要有 N 个独立的 Redis 实例。

  > 看文档吧, 很简单

[06 分布式系统中，如何回答锁的实现原理？ (lianglianglee.com)](https://learn.lianglianglee.com/专栏/架构设计面试精讲/06  分布式系统中，如何回答锁的实现原理？.md)

> 比较偏面试  不用看, 被包括且不如上面的细, 看总结足够了

---

- 明确分布式锁经常出现哪些问题，以及如何解决。 可用问题, 死锁问题, 脑裂问题

> 但面试官提问的重点不是停留在组件的使用上，而是你对分布式锁的原理问题的掌握程度。⁠‬‍⁠﻿这背后涉及了分布式锁的底层设计逻辑，是你需要掌握的。‌

- 基于关系型数据库实现分布式锁 (莫名其妙, 也没什么   并且Redis实现的分布式锁会比数据库实现的性能更高

- 基于分布式缓存实现分布式锁, 前面全都一样, 不用看

  > ‬‬‬⁠﻿‬﻿‬‍‌**你不能仅停留在操作上，因为这并不能满足应对面试需要掌握的知识深度，** 所以你还要清楚基于 Redis 实现分布式锁的优缺点
  >
  > 三个优点: 性能高效, 实现方便(SET命令以及Redis支持的lua脚本), 避免单点故障(???⁠﻿‍﻿﻿

- 如何合理设置超时时间

- Redis 如何解决集群情况下分布式锁的可靠性. 如果你能基于 Redlock 原理回答出怎么解决 Redis 集群节点实现分布式锁的问题，会成为面试的加分项。(不细)

> 但是在面试时，你要分清楚面试官的考查点，并结合工作中的业务场景给出答案，面试官不侧重你是否能很快地给出结果，而是你思考的过程。

[37｜分布式锁：如何保证Redis分布式锁的高可用和高性能？ | JUST DO IT (leeshengis.com)](https://leeshengis.com/archives/700522)

[37｜分布式锁：如何保证Redis分布式锁的高可用和高性能？ | 车斌的技术博客](https://chebin.tech/2023/11/09/37｜分布式锁：如何保证Redis分布式锁的高可用和高性能？/)

> **这个文章好牛逼啊, 和第一个一结合, 简直无敌了!!!!! ** **NB**
>
> 最后两个性能优化没懂, 其它都ok    好文章, 面试必备

> 分布式锁的本质——排他性 你在面试的过程中要先简明扼要地说清楚锁的实质，还有加锁和释放锁是什么。
>
> 在面试分布式锁的过程中，我发现大部分人只知道很基础的几个点，比如说只能回答出使用SETNX命令，又或者能答出要设置超时时间。当进一步追问的时候，就不知道了。这一节课的主题是用Redis来实现一个分布式锁，但是并不意味着分布式锁只能使用Redis来实现。简单来说，**支持排他性操作**的中间件都可以作为实现分布式锁的中间件

- 加锁. 分布式锁的本质——排他性
- 亮点 1 : 等待时间  在前面回答中，你提到加锁失败了，就要等一段时间，等别人释放锁。那么面试官可能问你，究竟该等多长时间？
- 亮点 2 : 如何实现等待机制  轮询(和监听删除事件)
- 亮点 3 : 加锁的时候若超时了, 该如何应对? 这个问题棘手之处在于你也不知道出现超时的时候，究竟有没有加锁成功。(懂了!NB)

- 锁过期时间

  > 所以你就要考虑这么一个问题，万一你加锁的那个线程崩溃了呢？比如说，它所在的机器整个崩溃了，应该怎么办？
  >
  > 你抓住关键词**没人释放**来回答。

- 亮点1：过期时间应该多长? 这个过期时间应该根据业务来设置.....

  > 总的来说，不管过期时间设置成多长，都可能遇到业务没能在持有分布式锁期间完成的情况。
  >
  > 这也是为了引导面试官发问。这种情况究竟该怎么解决呢？答案是续约。

- 亮点2：续约机制

  > 引入过期时间是为了防止持有锁的一方宕机无法释放锁, 而续约是为了防止过期时间内业务还没有执行结束.
  >
  > 那锁即将过期的时候, 如何判断是出问题了还是业务正常执行需要续约呢? 是不是如果宕机了, 其实续约功能也就失效了对吗? 续约器和对临界资源访问的程序是一体的对吗

  > 续约的主体：客户端主动续约（看门狗机制）
  >
  > **续约是由持有锁的客户端主动发起的，而不是由Redis主动检测和续约。**
  >
  > 具体流程：
  >
  > 1. **客户端获取锁时**：会设置一个较短的初始过期时间（如30秒），同时启动一个后台线程（看门狗线程）。
  > 2. **看门狗线程周期性检测**（比如每10秒）：
  >    - 检查业务是否仍在执行
  >    - 如果业务未完成，自动向Redis发送`EXPIRE`命令延长锁的过期时间
  > 3. **业务完成后主动释放锁**，同时停止看门狗线程。
  >
  > 优势：
  >
  > - **短过期时间 + 续约机制**：即使客户端崩溃，锁也能快速自动释放（最多等待初始过期时间），避免死锁
  > - **高性能**：Redis只需处理简单的`SETNX`和`EXPIRE`命令
  >
  > 如何判断续约必要性：心跳机制 + 超时判定
  >
  > **核心原理：通过客户端是否存活来判断是否需要续约**
  >
  > 判断逻辑：
  >
  > 1. **正常业务执行中**：
  >
  >    - 看门狗线程会持续发送续约心跳
  >    - Redis每次收到续约请求后重置过期时间
  >    - 示例：初始30秒过期，每10秒续约一次，锁实际可以无限续期
  >
  > 2. **客户端异常崩溃时**：
  >
  >    - 看门狗线程随进程终止
  >
  >    - 不再发送续约请求
  >
  >    - Redis中的key在过期时间到达后自动删除
  >
  > 典型实现方案对比
  >
  > | 方案                                   | 适用场景           |
  > | :------------------------------------- | :----------------- |
  > | 自动续约（看门狗）避免业务未完成锁过期 | 长耗时业务         |
  > | 固定过期时间(需要准确预估业务时间)     | 短耗时确定性业务   |
  > | 一次性锁(可能提前释放导致并发问题)     | 极高并发短耗时场景 |

- 亮点3：中断业务

  > 比如说分布式锁在续约失败的时候，给你发了一个信号。这个时候是否中断业务完全是看你的业务代码是如何实现的。

- 释放锁

  > 在释放锁的时候，要先确认锁是不是自己加的，防止因为系统故障或者有人手动操作了Redis导致锁被别人持有了。

- Redlock(看下面这段即可)

  > 首先，Redis的主从切换机制是解决不了这个问题的，因为Redis的主从同步是异步的。也就是说当你拿到一个分布式锁的时候，这个锁还没有同步到从节点，主节点就可能崩溃了。这个时候从节点被提升成主节点，里面并没有你的分布式锁，所以别人就可以拿到分布式锁。
  >
  > 你只需要掌握Redlock的基本概念就可以，不需要深入去研究。原因也很简单，就是目前绝大部分公司使用的分布式锁，都没有按照Redlock算法来实现，因为Redlock成本高，性能也比较差。

  

> todo 分布式锁的性能优化(懂了!NB)  singleflight算法可以好好看看
> 去分布式锁(没看懂, 不重要)



[21 ZooKeeper 分布式锁：实现和原理解析](https://learn.lianglianglee.com/专栏/ZooKeeper源码分析与实战-完/21 ZooKeeper 分布式锁：实现和原理解析.md)

[21 分布式锁：为什么基于etcd实现分布式锁比Redis锁更安全？](https://learn.lianglianglee.com/专栏/etcd实战课/21 分布式锁：为什么基于etcd实现分布式锁比Redis锁更安全？.md)

### 热key和大key

热key大key问题是什么? 解决方案是什么?

---

[06 Hot Key和Big Key引发的问题怎么应对？ (lianglianglee.com)](https://learn.lianglianglee.com/专栏/300分钟吃透分布式缓存-完/06 Hot Key和Big Key引发的问题怎么应对？.md)

- Hot Key

  > 主要是因为突发热门事件发生时，超大量的请求访问热点事件对应的 key，比如微博中数十万、数百万的用户同时去吃一个新瓜。数十万的访问请求同一个 key，流量集中打在一个缓存节点机器，这个缓存机器很容易被打到物理网卡、带宽、CPU 的极限，从而导致缓存访问变慢、卡顿。

- 解决方法

  > 1. 找出Hot key(???)
  > 2. 比如一个热 key 名字叫 hotkey，可以被分散为 hotkey#1、hotkey#2、hotkey#3，……hotkey#n，这 n 个 key 分散存在多个缓存节点，然后 client 端请求时，随机访问其中某个后缀的 hotkey，这样就可以把热 key 的请求打散，避免一个缓存节点过载
  >    这里还有方法 看不懂

- Big Key  缓存访问时，部分 Key 的 Value 过大，读写、加载易超时的现象。
  抽象, 没看懂

[如何找出优化大Key与热Key,产生的原因和问题_云数据库 Redis 版(Redis)-阿里云帮助中心 (aliyun.com)](https://help.aliyun.com/zh/redis/user-guide/identify-and-handle-large-keys-and-hotkeys)



[云数据库 Redis 热 Key 与 大 Key-最佳实践-文档中心-腾讯云 (tencent.com)](https://cloud.tencent.com/document/product/239/89468)

- 大key 热key定义

[37 数据分布优化：如何应对数据倾斜？ (lianglianglee.com)](https://learn.lianglianglee.com/专栏/Redis 核心技术与实战/37  数据分布优化：如何应对数据倾斜？.md)



### 秒杀场景

怎么用Redis实现秒杀

---

[‌‬﻿‌﻿‍‍‌﻿‬⁠⁠‌‍‍‬‍‍⁠‬‍﻿⁠‍‌‬﻿‌﻿秒杀 - 飞书云文档 (feishu.cn)](https://ls8sck0zrg.feishu.cn/wiki/wikcnMjrBLhw661kReWXuLYDJJh)

什么是秒杀?  秒杀的几个注意点

[秒杀专栏 - 飞书云文档 (feishu.cn)](https://ls8sck0zrg.feishu.cn/wiki/L1WKwK29ti7Z7dkIS2EcgSdnnoh)

[36 Redis支撑秒杀场景的关键技术和实践都有哪些？ (lianglianglee.com)](https://learn.lianglianglee.com/专栏/Redis 核心技术与实战/36  Redis支撑秒杀场景的关键技术和实践都有哪些？.md)

> 简单且清楚

- 秒杀场景的负载特征, 以及对支撑系统的要求

  > 第一个特征是瞬时并发访问量非常高。  需要使用 Redis 先拦截大部分请求，避免大量请求直接发送给数据库，把数据库压垮。
  >
  > 第二个特征是读 >> 写，而且读操作是简单的查询操作。

- 秒杀活动前 不需要Redis   秒杀活动结束后 压力小, 不讨论

- 秒杀活动开始  这个阶段的操作就是三个：库存查验、库存扣减和订单处理

  > 所以，这个阶段中最大的并发压力都在库存查验操作上。为了支撑大量高并发的库存查验请求，我们需要在这个环节使用 Redis 保存库存量
  >
  > 订单处理可以在数据库中执行  库存扣减操作不能在数据库执行(为什么? 若扣减不交给缓存, 而是数据库, 那么扣减后需要同步给Redis, Redis又同时负责着高并发的数据查验, 会很影响(问deepseek)
  >
  > 所以库存查验+库存扣减交给Redis缓存
  >
  > 需要查验和扣减商品库存，库存查验面临大量的高并发请求，而库存扣减又需要和库存查验一起执行，以保证**原子性**(防止读写并发出现问题, 很经典)。这就是秒杀对 Redis 的需求。
  >
  > <img src="C:\Users\yangzilong\Desktop\markdown\CS\Redis\Redis新\image-20250302221040002.png" alt="image-20250302221040002" style="zoom:50%;" />

- Redis 的哪些方法可以支撑秒杀场景

  > 秒杀场景对 Redis 操作的根本要求有两个 1.支持高并发(这里涉及Redis集群的知识, 没复习呢) 2.  原子性

- 基于原子操作支撑秒杀场景: 使用原子性的 Lua 脚本来实现库存查验和库存扣减

- 基于分布式锁来支撑秒杀场景: 使用分布式锁来保证多个客户端能互斥执行这两个操作

  > 先让客户端向 Redis 申请分布式锁，只有拿到锁的客户端才能执行库存查验和库存扣减。这样一来，大量的秒杀请求就会在争夺分布式锁时被过滤掉。而且，库存查验和扣减也不用使用原子操作了，因为多个并发客户端只有一个客户端能够拿到锁，已经保证了客户端并发访问的互斥性。
  >
  > **我们可以使用切片集群中的不同实例来分别保存分布式锁和商品库存信息**。使用这种保存方式后，秒杀请求会首先访问保存分布式锁的实例。如果客户端没有拿到锁，这些客户端就不会查询商品库存，这就可以减轻保存库存信息的实例的压力了。



- 当然，对于秒杀场景来说，只用 Redis 是不够的。秒杀系统是一个系统性工程....







详细来说, 对象必学, 执行流程不算那么重要, 但是也学一学, 持久化必学吧, 且学过了, 场景必学! 很重要? 集群没那么重要, 但是老子学过了

Redis自测题, 题库 反复干, 这样才能在面试的时候吟唱









----



[‍﻿‬‬‬﻿‍‌⁠‌﻿⁠﻿‌﻿‍﻿‌⁠⁠‌‬⁠Redis是单线程还是多线程？ - 飞书云文档 (feishu.cn)](https://ls8sck0zrg.feishu.cn/wiki/K2nDw8Qt6iMvWHkaG0zcok3LnCc)



[36｜Redis 单线程：为什么 Redis 用单线程而 Memcached 用多线程？ | JUST DO IT (leeshengis.com)](https://leeshengis.com/archives/699268)

> ! leeshengis
>
> **这个文章还是一如既往的神**

> ?
>
> 亮点1不行, 跳过
>
> <u>**6.0之后的多线程IO到底是怎么实现的?**</u>

> *
>
> 而实际上，Redis 并不是单线程的。业界说 Redis 是单线程的，是指它在处理命令的时候，是单线程的。在 Redis 6.0 之前，Redis 的 IO 也是单线程的，但是在 6.0 之后也改成了多线程。但是其他部分，比如说持久化、数据同步之类的功能，都是由别的线程来完成的。因此严格来说，Redis 其实是多线程的。
>
> 有关 Redis 的线程模型面试是纯理论面试，所以你需要记忆的东西很多。
>
> 一般来说，面试官都会问你“为什么 Redis 是单线程的，但是又能做到高性能？”很多人会下意识地回答：“因为 Redis 是完全内存操作的。”这个理由很关键，但是这并不是面试官想要的答案，他希望你回答的是 Redis 的 IO 模型。
>
> 后面在 6.0 的时候，Redis 改成了多线程模型，但是基本原理还是 Reactor + epoll。
>
> 亮点二：Redis 为什么引入多线程？    后面看文章

有关6.0的多线程IO模型, 下面文章可用作补充



[⁡⁢‬⁤‌﻿﻿﻿⁣⁢⁤﻿‬⁢‍‬⁣⁣⁡‬⁤⁤‌⁢‌﻿‬⁤‌⁣⁡‬‌⁢‬⁣﻿‌﻿Redis在内存中是怎么存储的 - 飞书云文档 (feishu.cn)](https://ls8sck0zrg.feishu.cn/wiki/wikcn9BKnbwsckaPqAoaI1zwMJh)

> 总结与评价 : 
>
> 这里其实就是讲的, Redis本身就是一个KV存储结构, 所以最根本上就是一个字典dict, 也就是一个哈希表
>
> 里面讲的比较简单, 其实redis设计与实现这本书都讲过了

[Redis内存面试与分析 - 飞书云文档 (feishu.cn)](https://ls8sck0zrg.feishu.cn/wiki/wikcnzOrOuLJYEyehoG9vUOuMt1)

三个问题.. 真不知道这B文档干嘛来的, 其实知道了上一个文档, 这个就知道了, 主要还是考察Redis到底是如何存储KV的, 还有过期是怎么实现的

[‌﻿⁢‌‍‌﻿‬‬⁣⁡⁣‌‌﻿‌⁤⁢⁡⁡⁢⁣﻿⁡‌﻿⁡⁣⁤‍‬⁣⁡⁣‍‬⁤﻿﻿‬‍⁢⁤⁣‬Redis是单线程，还是多线程？（重点理解） - 飞书云文档 (feishu.cn)](https://ls8sck0zrg.feishu.cn/wiki/wikcnF8yKiMzoD38GR6fpaElhlb)

核心就是围绕Redis单线程这个问题

[﻿‬﻿⁣⁣‬‌⁤⁣⁡‍⁤⁢‍⁣‌⁤⁢⁢‌⁣⁢⁣⁢⁡⁤‬⁢⁣‬‌‌⁤﻿﻿‌﻿‬⁡单线程为什么能这么快（重点理解） - 飞书云文档 (feishu.cn)](https://ls8sck0zrg.feishu.cn/wiki/wikcnwpT0SIYOthdl78S7OZouqf)

这里讲的其实还不错, 主要从单线程 + IO多路复用的角度来看的

[⁡⁡⁣⁤﻿‌﻿⁢‌‌⁢‍‬‌⁢⁢⁢⁡﻿⁤‍⁢‌‍‬⁣⁤‍⁢‍⁡⁣‌⁢‍‍‍⁤⁤⁡⁢Redis处理过程-源码解析（稍微了解即可） - 飞书云文档 (feishu.cn)](https://ls8sck0zrg.feishu.cn/wiki/wikcnts0xtSCT0XCU0E66ce8wCd)

todo

[‌‍⁤‍‌‍⁡⁣⁤⁣⁣‬‬‍⁡﻿⁢⁢⁡‬‬‌⁣⁡⁣﻿‍⁡⁢‬⁢⁣⁣⁡‍⁢‬‍⁡‌⁢‌Redis单线程面试与分析 - 飞书云文档 (feishu.cn)](https://ls8sck0zrg.feishu.cn/wiki/wikcnr52jhHa0drtDxvAMJqI9sh)

有几个问题, 答的一般吧, 但是我们可以直到问题, 之后再补充回答一下

[‌⁤⁤⁤⁣⁢⁤‌⁣‬⁤‌‬⁢‍⁤⁡﻿﻿⁡‌﻿‍⁤‌⁤⁤⁡‍⁢⁢﻿‍⁣⁢⁣﻿‍⁤‍﻿⁣多线程是怎么回事（需要了解） - 飞书云文档 (feishu.cn)](https://ls8sck0zrg.feishu.cn/wiki/wikcniustSxgJNYcpCQZnjsiEUf)

因为上述情况，Redis选择了引入多线程来处理网络I/O，仍然使用单线程框架来执行Redis命令，这样既保持了Redis核心的单线程处理架构，完全兼容以前的实现，又引入了多线程解决提升网络I/O的性能。

todo

[‌‌⁣‬⁢⁣⁤⁣‬‬⁢‍⁡‬‬‌⁣⁤﻿⁣⁡⁢⁢‍⁣⁣⁤⁡⁡‍⁤‍‬‬‍﻿⁤Redis多线程面试与分析 - 飞书云文档 (feishu.cn)](https://ls8sck0zrg.feishu.cn/wiki/V4ZTwvw61ifzUzkx18Ccg19OnVN)

就三个问题.... 上面这个文档的对应问题... 回答的其实一般

[⁤⁤⁡⁤⁣⁡﻿‍‌⁡‬﻿⁤‍‬⁣‬‬⁡‍⁢⁡⁡⁣⁤⁤‬⁣‍‍⁡⁢‍‌⁤‌⁡‌‬‬内存满了怎么办 - 飞书云文档 (feishu.cn)](https://ls8sck0zrg.feishu.cn/wiki/wikcn75mzfzhsiV86pzaasPlWIf)

讲的不是很多... 说出了8种内存淘汰机制

[⁡⁤‌‍⁣﻿⁣⁢‬‬‌‬⁣‌﻿⁣⁢⁤‬‌‍‬‌⁤⁡‬⁤‌‌⁢⁡‍﻿‍⁢⁡⁣⁡内存淘汰算法-LRU - 飞书云文档 (feishu.cn)](https://ls8sck0zrg.feishu.cn/wiki/wikcnE4S4MmoAFPljPzh50QQeuh)

todo  有点拉

[﻿‬⁤﻿⁡‍⁣⁤⁢‍⁤⁣⁡‬⁤⁢⁣‬⁡⁣‍﻿⁣⁡﻿‍⁤⁡⁡⁡⁣﻿‍‌⁡⁢⁡内存淘汰算法-LFU - 飞书云文档 (feishu.cn)](https://ls8sck0zrg.feishu.cn/wiki/wikcnISEtOj5hEKa84ZcNOg4q2b)

todo..  还行吧... 

[⁤⁤⁡⁤⁣⁣‍﻿﻿⁣‬﻿‬⁤‍‌‬⁢‌‌⁢﻿‌‍﻿‌⁡‬⁤‬﻿﻿⁡⁢⁢⁤⁢‍‍‍⁢﻿﻿内存淘汰面试与分析 - 飞书云文档 (feishu.cn)](https://ls8sck0zrg.feishu.cn/wiki/wikcnBBUC0CYHy5G7fMmgPPROzg)

几个问题, 上面三个文档对应的面试问题....  不是很多啊.. 直觉来看

[‌⁢⁡⁢‬‍⁡⁤⁢‬‍⁣‬‍⁣⁡⁤⁢⁡⁡‍⁣⁤⁣‍⁢‬⁡‬⁡﻿⁢﻿⁤⁤⁣‌‍‌⁣⁡‌⁣缓存一致性怎么保证 - 飞书云文档 (feishu.cn)](https://ls8sck0zrg.feishu.cn/wiki/wikcnEJdzUmS3CgUHXUCjJY5Iad)

?

[实现 Redis 分布式锁 - 飞书云文档 (feishu.cn)](https://ls8sck0zrg.feishu.cn/wiki/wikcnaF1qH0IuDirpmALM8rf79g)

todo

[Redis 大 Key 对持久化有什么影响？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/redis/storage/bigkey_aof_rdb.html#大-key-对-aof-日志的影响)

> 分别说说这三种策略，在持久化大 Key 的时候，会影响什么？
