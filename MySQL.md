# 逻辑架构

### 一条SQL的执行过程

[执行一条 select 语句，期间发生了什么？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/mysql/base/how_select.html#mysql-执行流程是怎样的)

> 难度 一般, 质量 : 不错, 再次看的时候应该好理解的   其实挺清晰的, 可以进行的快点~ 

> 总结 : 整体来说没啥难度, 将一条select的执行过程完整描述出来了, 大部分都是在server层, 只有最后执行语句时, 才会由server层与存储引擎层进行交互, 因为存储引擎层是真正负责数据的存储和提取的. 且也将server与存储引擎层的大致交互过程描述出来了
>
> 索引下推讲的不错, 大致就是减少了二级索引的回表, 提高了性能

一 连接器: TCP 三次握手   建立网络连接   连接器就要开始验证你的用户名和密码    连接器就会获取该用户的权限，然后保存起来

二 查询缓存: (server层, key select查询语句-value 查询结果) MySQL 8.0之后已去除

三 解析SQL: 解析器: 解析器对 SQL 查询语句进行词法分析(识别出4个Token，其中有2个Keyword，分别为select和from)、语法分析(判断是否满足MySQL语法)，然后构建语法树(方便后续模块读取表名、字段、语句类型；

四 执行SQL:  执行 SQL 查询语句的流程
.1.  预处理阶段 预处理器 检查 SQL 查询语句中的表或者字段是否存在 将 `select *` 中的 `*` 符号，扩展为表上的所有列；
.2.  优化器: 为 SQL 查询语句先制定一个执行计划: 基于查询成本的考虑， 选择查询成本最小的执行计划；
.3. 执行阶段: 根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；执行器(MySQL 就真正开始执行语句) 在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。  三方: 客户端, 执行器, 存储引擎  (还讲了索引下推)

### 引擎分类

[(十三)MySQL引擎篇：半道出家的InnoDB为何能替换官方的MyISAM？ - 掘金 (juejin.cn)](https://juejin.cn/post/7160557698642083847)

MySQL存储引擎有哪些?
InnoDB和MyISAM存储引擎有什么区别?

> 质量较高   (比较适合学完MySQL之后总结复习回顾整体)
>
> 总结 : 讲了InnoDB的优点, MyISAM的缺点, MyISAM的优点
>
> 整体难度不难, 结合了索引, 事务, 锁, 挺不错的

> - 两款引擎的背景介绍
> - 两款引擎在存储数据时，本地文件的不同点。
> - 索引支持的对比(聚簇索引和非聚簇索引, 为什么MyISAM不支持聚簇索引)
> - 事务机制的对比(原子性) - MyISAM不支持事务   只有InnoDB支持/提供undo log
> - 故障恢复的对比(`MyISAM`并没有`InnoDB`引擎可靠 InnoDB有redo-log, 而MyISAM没有)
> - 锁粒度的对比(MyISAM不支持聚簇索引, 所以不支持行锁) InnoDB: 因此想要对一行数据加锁时，只需要锁定聚簇索引的数据即可   (mkdwsm 我把MyiSAM引擎中的行数据加上锁不可以吗??)
> - 并发性能的对比 (InnoDB不仅支持行锁, 还有MVCC优化了读写并发场景)
> - 内存利用度的对比
>
> 二   对上方的内容的总结
>
> 三、MyISAM引擎真的一无是处吗？MyISAM的优点
> 结合`MyISAM`引擎的特性而言，它适用于一些不需要事务、并发冲突低、读操作多的表
> 特别适合使用`MyISAM`引擎，即`MySQL`利用主从架构，实现读写分离时的场景

> *
>
> 依旧是前面的这个例子，通过主键索引查询的`SQL`语句，会直接定位到聚簇索引的数据，然后对`ID=1`的数据加锁。而第二条通过普通索引查询数据的`SQL`语句，经过查询后会得到一个值：`ID=1`，然后会拿着这个`ID=1`的值再去回表，在聚簇索引中再次查询`ID=1`的数据，找到之后发现上面已经有线程加锁了，当前线程就会阻塞等待上一个线程释放锁。

`redo-log`日志，`InnoDB`在启动时，同样会在内存中构建一个`redo_log_buffer`缓冲区，在磁盘中也会有相应的`redo-log`日志文件

`undo-log`日志，`InnoDB`在`MySQL`启动后，会在内存中构建一个`undo_log_buffer`缓冲区，同时在磁盘中也有相应的`undo-log`日志文件。

# InnoDB存储引擎

### 一行记录的存储格式

[MySQL 一行记录是怎么存储的？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/mysql/base/row_format.html)

> 数据库表的数据存储在哪里
>
> InnoDB表空间结构有哪些组成?
>
> varchar如何保存长度?
>
> Null值如何保存?

- MySQL 的数据存放在哪个文件?   由存储引擎决定, InnoDB: db.opt t_order.frm  t_order.ibd
-  表空间文件的结构是怎么样的？  表空间由行（row）页（page, 16kb, 内存与数据库磁盘IO的基本单位）区（extent  1MB, 为了使B+索引树中的相邻页的物理存储也是相邻的, 将磁盘的随机IO优化为顺序IO）段（segment）组成
- InnoDB 行格式有哪些  讲了COMPACT的行格式  变长字段长度列表 + NULL值列表 + 记录头信息 (+) 三个隐藏字段 + 记录的真实数据
- varchar(n) 中 n 最大取值为多少(n是字符个数) 一行记录最大能存储 65535 字节的数据 = 变长字段长度列表占用字节数+NULL值列表占用字节数+所有真实字段的字节数(不包括TEXT、BLOBs 这种大对象类型)    且和数据库表的字符集强相关, 因为字符集决定了一个字符占用几个字节, 比如ascii 字符集, 1个字符占用1字节
- 行溢出, MySQL如何处理  一个页可能就存不了一条记录。这个时候就会发生行溢出，多的数据就会存到另外的「溢出页」中。(和行格式有关, 三个主流行格式的区别貌似仅此?)

### 数据页

[从数据页的角度看 B+ 树 | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/mysql/index/page.html)

> 聚簇索引和非聚簇索引的B+树结构有什么区别?

- InnoDB是如何存储数据(记录)的?   **InnoDB 的数据是按「数据页」为单位来读写的**   InnoDB的数据页的结构组成, 如何利用页目录来快速检索数据页中的记录
- B+ 树是如何进行查询的？如何建立合适的索引，才能方便定位记录所在的页。  (简略, 大致了解即可)
- 聚簇索引和二级索引 (重复)

> GPT
>
> MySQL的InnoDB存储引擎使用了一种被称为B+树的数据结构来存储数据。数据在InnoDB中是以页（Page）为单位存储的，页是InnoDB磁盘管理的基本单位。默认情况下，每个页的大小为16KB，但这个大小是可以配置的。每个页可以包含多种不同类型的信息，但最常见的页类型是数据页（也称为索引页），它用于存储表的数据和索引信息。下面是数据页的结构概览： 
>
> 1. **文件头部（File Header）**：包含页的一般信息，如页的类型、所属的表空间信息、页号等。
> 2. **页头部（Page Header）**：包含了页的状态信息，如记录数、最后一个记录的位置、空闲空间的起始位置等。
> 3. **Infimum 和 Supremum 记录**：每个数据页都会有这两个虚拟的记录，Infimum 记录小于该页上所有其他记录的值，Supremum 记录大于该页上所有其他记录的值。这两个记录用于辅助记录的插入操作。
> 4. **用户记录（User Records）**：实际存储的表数据，它们按照主键的顺序存储在页中。
> 5. **空闲空间（Free Space）**：页中未被使用的空间，新的记录或者记录的更新会使用到这部分空间。
> 6. **页目录（Page Directory）**：为了快速访问页中的记录，InnoDB在页的尾部维护了一个目录，这个目录包含了页中所有记录的相对位置。目录中的槽点指向记录的列表，从而加速查找过程。
> 7. **文件尾部（File Trailer）**：存储页的尾部信息，主要是校验和，用于检测页数据在磁盘或内存中是否被破坏。
>
> 这种组织方式允许InnoDB高效地执行数据的读取、插入、更新和删除操作。特别是对于大量数据的随机访问，B+树的结构减少了磁盘I/O的需要，因为它保持了数据的物理和逻辑顺序一致。此外，InnoDB的事务日志、MVCC（多版本并发控制）、行级锁等特性都是建立在这种数据页结构之上的。

InnoDB 里的 B+ 树中的**每个节点都是一个数据页**

### Buffer Pool

[揭开 Buffer Pool 的面纱 | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/mysql/buffer_pool/buffer_pool.html)

> InnoDB对LRU做了哪些优化?  (Least Recently Used)

> 不难, 不是很多, 讲的不错.
>
> Buffer Pool里的核心就是页, 各种页, 如何管理这些缓存页? LRU算法做了哪些优化? (两大优化)

- Buffer Pool的初步介绍 (缓冲池, 缓存, InnoDB)

- Buffer Pool缓存什么?  统一称为缓存页, 配有控制块 (缓存了实际的数据之后称为索引页 数据页等...)

- 如何管理空闲页?   Free链表(空闲链表, 管理了哪些缓存页是空闲的)

- 如何管理脏页?  (提高写性能)

- 为什么要有LRU, 三种页, 三种链表, 简单的LRU算法有什么问题

- 1. 预读失效  划分old & young区域

- 2. Buffer Pool污染  (为了解决批量数据访问，大量热数据淘汰的问题。)  old 进入到 young 区域条件增加了一个**停留在 old 区域的时间判断**。    (???????????????????) 

     > 举例, 比如一个查询语句是全表查询, 那么所有数据都会进行一次查询, 若表的数据量较大, 那么就会全部加载到LRU链表中
     > 而LRU事实上是为了那些常被访问的数据准备的, 而不是只访问一次的数据, 所以, 若加载到old区域和被访问的时间间隔较长, 说明这个数据是加载到LRU之后, 后续又被访问到了, 也就是起到了缓冲池的作用, 若是立即访问的, 也就是时间间隔较短, 此时不应加载到young区域, 所以有了这个时间间隔的判断机制

- 脏页什么时候被刷入磁盘  (Write Ahead Log 策略，即先写日志，再写入磁盘)
  当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘； (???????????????????????)

> 链表? 也就是, 节点 节点内的指针指向的是控制块?

### Change Buffer

> 普通索引和唯一索引有什么区别? 
> 哪个更新性能更好? 
> 如何进行选择?

[09 普通索引+和唯一索引，应该怎么选择？ (lianglianglee.com)](https://learn.lianglianglee.com/专栏/MySQL实战45讲/09  普通索引和唯一索引，应该怎么选择？.md)

> 一个全新的内容 :Change Buffer 且结合Change Buffer对比了普通索引和唯一索引的读写性能
>
> 写的很不错, 很NB, 且针对了具体的情况. 
>
> 最后一部分没看, 之后再说, 主要是结合了redo log, 这个我有点忘了 TODO

- 唯一索引和普通索引查询的性能差距微乎其微

- change buffer 机制的介绍以及优点

  > 对不在内存中的数据页的更新操作存储在change buffer中, 能大幅提高更新操作的性能, 还能节省内存空间(因为不用立即将数据页加载到内存中)
  >
  > 唯一索引的更新操作不能配合change buffer

- change buffer的使用场景(写多读少(写完之后不会立即做查询操作), 普通索引)

### char和varchar

error  : [  MySQL中char与varchar的区别：存储机制、性能差异 | 毛英东的个人博客 (maoyingdong.com)](https://www.maoyingdong.com/mysql-char-vs-varchar/)

[02 字符串类型：不能忽略的 COLLATION](https://learn.lianglianglee.com/专栏/MySQL实战宝典/02  字符串类型：不能忽略的 COLLATION.md)

char 和 varchar区别 性能差异

varchar(10) varchar(100) 如果只是用了5字节, 内存和文件分别占用多少字节

> 评价 : 总体很简单, 内容也很少

> char : 存字符串 + 字节长度, char N 不足N字节时使用0x20 - 空格字符填充
>
> varchar : 存字符串 + 字节长度

> CHAR 本质也是变长的。

# 索引

真去了解索引的基础知识, 还是前两个

后面的几个其实很简单

### 索引数据结构

![image-20240222194127271](C:\Users\yangzilong\Desktop\markdown\CS\MySQL\MySQL原理\MySQL.assets\image-20240222194127271.png)

三个文档, 两个视频

#### [08 索引：排序的艺术 ](https://learn.lianglianglee.com/专栏/MySQL实战宝典/08  索引：排序的艺术.md)

- 索引是什么?  索引与排序

- **讲B+树索引的结构**  很具体, 从磁盘IO的角度

- **B+索引树的插入性能问题-数据顺序插入与数据无序插入的性能比较**   所以，我再次强调： 在表结构设计时，主键的设计一定要尽可能地使用顺序值

- 两个关于索引的补充

> 为什么说B+是基于磁盘的平衡树?  主要就是, 矮, 结构有特点

#### [为什么 MySQL 采用 B+ 树作为索引? - 小林coding](https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html)

> 开头, B B+ 对比B B+  其余带过即可   3min...
>

- 什么数据结构的索引是好的?  - 结合磁盘IO  最终就是两个点 1. 尽可能减少磁盘IO次数, 因为很耗时 2. 支持范围查询

- 知道了目标, 对比各种结构    **树的高度就等于每次查询数据时磁盘 IO 操作的次数**
  线性数组: 插入的效率过低, O(N), 
  二分查找树: 退化O(N)的风险, 且树的高度不够低, 不支持范围查询
  自平衡二叉(AVL, 红黑): 不够矮, 
  B树, 高度低, 但是B 树的每个节点都包含数据(索引+记录), 用户记录数据可能远远超过索引, 非 A 记录节点记录数据是没用的, 我们只是想读取这些节点的索引数据来做比较查询，这样「非 A 记录节点」里的记录数据不仅**增多磁盘 I/O 操作次数，也占用内存资源。** 另外范围查询要中序遍历, 这会涉及多个节点的磁盘 I/O 问题, 降低速度
  B+  **非叶子节点中有多少个子节点，就有多少个索引；**

- 对比B+和B, 为什么选择了B+
  1. B+更矮(因为B的所有节点都既存数据又存索引), 单点查询大多情况更快
  2. B+插入和删除的效率更高(不知道为什么)
  3. B+的范围查询更高效, 因为叶子节点用双向链表串联起来

- 最后简单说了一下MySQL的B+(重复)

> B+和B的区别
> 聚簇和非聚簇的区别   聚簇和二级的区别仅是叶子节点存放的数据不同
>
> MySIAM和InnoDB的B+索引的区别 其实就是聚簇和非聚簇的区别, 因为MySIAM只支持非聚簇索引, 叶子节点存储的就是数据的物理地址

## 索引存储(New)

[09 索引组织表：万物皆索引 (lianglianglee.com)](https://learn.lianglianglee.com/专栏/MySQL实战宝典/09  索引组织表：万物皆索引.md)

todo



## 联合索引 - 组合索引

> 联合索引的结构是怎样的
>
> 如何利用联合索引提高查询性能

> 3分钟吧,  就两三个例子而已

[10 组合索引：用好，性能提升 10 倍！ (lianglianglee.com)](https://learn.lianglianglee.com/专栏/MySQL实战宝典/10  组合索引：用好，性能提升 10 倍！.md)

- 组合索引的简单介绍 + 几个简单的SQL示例

- 实例 组合索引优化了一个SQL

- 示例 组合索引+覆盖索引减少回表

## 索引失效

[索引失效有哪些？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/mysql/index/index_lose.html#索引存储结构长什么样)

> 有哪些索引失效的场景
>
> 为什么会失效

> 3分钟, 图一般, 索引讲的一般, 其它的不用看, 直接知道失效的几个场景即可

- 他妈的, 又讲

索引失效的场景

1. 对索引使用左或者左右模糊匹配 - `like %xx` 或者 `like %xx%`   **因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。**

2. 对索引使用函数(8.0新增函数索引)

3. 对索引进行表达式计算  `select * from t_user where id + 1 = 10;`

4. 对索引隐式类型转换   字符串类型(varchar)字段的索引, 使用整型进行搜索就会失效  (MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。

5. 联合索引非最左匹配   还趁机讲了一下索引下推: server层的任务, 下推到了存储引擎层执行 减少了回表

6. WHERE子句中的OR : OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

## 索引选择

[11 索引出错：请理解 CBO 的工作原理 (lianglianglee.com)](https://learn.lianglianglee.com/专栏/MySQL实战宝典/11  索引出错：请理解 CBO 的工作原理.md)

> MySQL数据库中的优化器是怎么执行的? 根据什么标准选择索引?

> 文章不错, 内容不多, 不难理解
>
> 示例前面写的很好, 且较为新颖, 示例较容易理解

- SQL优化器的介绍, **基于成本选择索引 CPU Cost + IO Cost = Server Cost + Engine Cost**

  > 在关系型数据库中，B+ 树索引只是存储的一种数据结构，具体怎么使用，还要依赖数据库的优化器，优化器决定了具体某一索引的选择，也就是常说的**执行计划**。
  >
  > **而优化器的选择是基于成本（cost），哪个索引的成本越低，优先使用哪个索引。**
  >
  > SQL 优化器会分析所有可能的执行计划，选择成本最低的执行，这种优化器称之为：CBO（Cost-based Optimizer，基于成本的优化器）。

- CPUCost IOCost的具体说明

- 示例1  `再次强调，并不是 MySQL 选择索引出错，**而是 MySQL 会根据成本计算得到最优的执行计划，** 根据不同条件选择最优执行计划，而不是同一类型一成不变的执行过程，这才是优秀的优化器该有的样子。`
  示例2  高选择性 数据倾斜

## 索引应用

[(五)MySQL索引应用篇：建立索引的正确姿势与使用索引的最佳指南！ - 掘金 (juejin.cn)](https://juejin.cn/post/7149074488649318431)

> 索引优缺点 / 如何正确使用索引 / 哪些场景下适合/不适合建立索引

> 讲的比较浅, 很多之前都学过了
>
> 质量一般, 单个知识较短, 有些浅看一下即可吧 最后两个没接触过

一 索引的优劣

主键索引的陷阱 : 主键有序比无序插入效率高   联合索引存在的陷阱 : 索引最左匹配原则  前缀索引存在的弊端  全文索引存在的弊端

唯一索引存在的弊端   (查找比普通好, 但是插入比普通多一步检查?)   (这里说的不如另一个讲唯一索引的那个文章好, 普通索引 + change buffer会有很大优势)         哈希索引的问题 无序, 无法基于哈希索引进行排序, 分组

二 建立索引的正确姿势

回表带来的性能消耗  (有点莫名其妙了)

建立索引时需要遵守的原则

联合索引的最左匹配原则

三 索引失效与使用索引的正确姿势    (其实这里是指我们编写`SQL`时，要注意的点)

explain简单介绍

索引失效

情景一 :  or  情景2 : like '%111'   情景三: (这里其实没有讲具体的原因)

情景4 5 6 7 

四 几个索引相关的重点知识

索引覆盖  索引下推(New)   MRR   Index Skip Scan索引跳跃式扫描

> 那什么又叫做索引下推呢？也就是将`Server`层筛选数据的工作，下推到引擎层处理。

# 事务

## 事务的ACID

[第19章 从猫爷被杀说起-事务简介](https://relph1119.github.io/mysql-learning-notes/#/mysql/19-从猫爷被杀说起-事务简介) (第19章)

AICD

atomicity (原子性)  设计数据库的大佬需要保证如果在执行操作的过程中发生了错误，把已经做了的操作恢复成没执行之前的样子

isolation (隔离性)  事务和事务之间互相影响?

consistency (一致性)

> 一致性: 数据库完成一部分, 另一部分还需要靠写业务代码的程序员自己保证 (由于性能问题, 不能把一致性完全交给数据库)
>
> 数据库某些操作的原子性和隔离性都是保证一致性的一种手段，在操作执行完成后保证符合所有既定的约束则是一种结果。
>
> ![image-20240116160039706](C:\Users\yangzilong\Desktop\markdown\CS\MySQL\MySQL原理\MySQL.assets\image-20240116160039706.png)

durability (持久性)  数据库操作所修改的数据都应该在磁盘上保留下来

事务的概念  把需要保证`原子性`、`隔离性`、`一致性`和`持久性`的一个或多个数据库操作称之为一个`事务`

## 事务隔离级别

1. 事务并发会产生什么问题

2. 事务隔离级别有哪些? 怎么实现的?

3. 读已提交和可重复读的区别

4. MVCC是什么? 解决什么问题? 实现原理?

5. 可重复读隔离级别彻底解决幻读了吗?

#### [事务隔离级别是怎么实现的?](https://xiaolincoding.com/mysql/transaction/mvcc.html)

**这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。**

> ez   很短的, 5-10min就可以搞定, 事务的各个基础方面都讲了一下, 然后重点讲了读提交和可重复读是怎么依靠ReadView来实现的.
>还是很不错的
> 
>read view 的可见性判断一定是针对read view创建时的那一刻的, 因为创建好之后其它事务的提交并不会动态地影响read view以及可见性的判断

- 事务的四大特性
  接下来重点讲解事务的隔离性, 要想知道为什么事务要有隔离性, 我们就要知道事务并发时会引发什么问题)

- 并行(并发)事务带来的问题: 脏读, 不可重复读, 幻读

- 事务的隔离级别有哪些?  四种隔离级别与事务并发造成的问题之间的联系(也就是隔离级别越高, 解决的事务并发问题就越多)

  > 事务并发造成的问题的影响程度不同, 是有严重性排序的
  >
  > MySQL 在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生（注意是很大程度避免，并不是彻底避免）

- 浅谈各个隔离级别大致都是如何实现的?  重点引出ReadView 以及 读提交&可重复读

- Read View 介绍+可见性判断规则

  > 其实很简单, 在ReadView生成前已提交的事务所修改或生成的数据记录可见, 在ReadView生成时还未提交的(包括此时还未启动以及启动了还未提交)....不可见

> 你妈, 这么简单, 然后我当时... 玩去了???

- 可重复读是怎么工作的?

> **可重复读隔离级别是 启动事务 时生成一个 Read View，然后整个事务期间都在用这个 Read View**。
>
> **「可重复读」隔离级别下在事务期间读到的记录都是事务启动前的记录。(事务启动之前其它已经提交的事务产生的记录**

- 读提交是怎么工作的?

> **读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View**。  而恰好不可重复读这个问题就是读到了其他已提交事务所修改或产生的记录

>串行化怎么实现的???

#### [MySQL 可重复读隔离级别，完全解决幻读了吗？](https://xiaolincoding.com/mysql/transaction/phantom.html)

> ez 短     总结 : 锁没学过, 其余较简单, 5 - 10min即可 还不错
>

> 这个文章一定是基于可重复读隔离级别的(读提交隔离级别一定是存在幻读问题的, 因为read view会产生新的, 可见性会被刷新, 别的事务的提交的更新是会看到的. 且读提交的当前读并不会加入next-key lock(?))

- 什么是幻读现象?

- 可重复读隔离级别下的**快照读**是如何避免幻读的?  

  > MVCC ReadView 哈哈, 因为ReadView没变, 所以可见性没变, 所以不会幻读(快照读一定是在版本链中根据readview来进行可见性判断的)

- 可重复读隔离级别下的**当前读**是怎么解决幻读问题的?  锁

- 幻读被完全解决了吗?    可重复读隔离级别虽然很大程度上避免了幻读，但是还是没有完全解决幻读。

第一个幻读残留场景   关键在于这个更新是当前读, 所以是会更新成功的, 因为版本链中的事务id被更新为当前更新此记录的事务了, 所以幻读

第二个残留场景 先快照  后当前(因为锁一定是在当前之后才加的, 所以建议尽早当前读, 尽早加锁, 就安心了)





---





> ‌ [MVCC协议：MySQL 在修改数据的时候，还能不能读到这条数据? ](https://leeshengis.com/archives/675235)
>
> > 还不错吧, 真挺好, 因为是针对面试的
> >
> > 理解的就不用深究了, 有些表述我可以学习一下, 很针对面试, 特别是最后几个部分
>
> 为什么需要MVCC?    这里讲的说实话, 还真挺不错的, 其实就是为了读写并发, 不阻塞, 因为即使用读写锁, 读写也会阻塞
>
> 隔离界别的介绍  (这个文章好牛逼呀)   数据库的隔离级别是**一组规则，**用来控制并发访问数据库时如何分配、保护和共享资源。不同的隔离级别在不同的并发控制策略之间进行调整，从而提供了不同的读写隔离级别和安全性。用人话来说，就是隔离级别代表了一个事务是否了解别的事务以及了解程度怎么样。
>
> 三种读异常的介绍
>
> > - **脏读**是指读到了别的事务还没有提交的数据。之所以叫做“脏”读，就是因为未提交数据可能会被回滚掉。
>
> 快照读与当前读
>
> 版本链 undo log  引出ReadView (MVCC 里面的 V 指的就是这个数字
>
> > Read View 你可以理解成是一种可见性规则。前面你已经知道了 undolog 里面存放着历史版本的数据，当事务内部要读取数据的时候，Read View 就被用来控制这个事务应该读取哪个版本的数据。
>
> > Read View **只用于已提交读和可重复读**两个隔离级别，它用于这两个隔离级别的不同点就在于**什么时候生成 Read View**。
>
> > 所以你可以看到，虽然事务 2 提交了，但是事务 A 完全不知道这回事，因此它还是读到 x=1。
>
> > 有些时候面试官会在面了锁之后，将话题引到 MVCC，问你为什么有了锁，还需要 MVCC？你在回答的时候要答出关键词**避免读写阻塞。**单纯使用锁的时候，并发性能会比较差。即便是在读写锁这种机制下，读和写依旧是互斥的。而数据库是一个性能非常关键的中间件，如果某个线程修改某条数据就让其他线程都不能读这条数据，这种性能损耗是无法接受的。所以 InnoDB 引擎引入了 MVCC，就是为了减少读写阻塞。
>
> > 这个文章真不错, 缺点是, 有关RV的四个字段讲的不够细, 不过也ok了
>
> 针对面试的部分
>
> 好问题: 为什么 有了锁, 还要MVCC?  所以 InnoDB 引擎引入了 MVCC，就是为了减少读写阻塞。‬‍⁤‍⁡⁣‍⁣⁣⁣⁡⁣⁢⁢﻿⁤‍‍⁣⁢‬‬‌⁤⁤﻿⁤﻿⁢﻿⁢⁤⁤⁡﻿

# 锁

### 锁类型

MySQL有哪些锁?  对表结构修改会加什么锁?

MyISAM有行级锁吗?

行级锁有哪些?

InnoDB怎样加行级锁的?

---

#### [MySQL 有哪些锁？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/mysql/lock/mysql_lock.html)

> 简单清楚, AUTO-INC锁没看
>
> auto-inc todo

- 全局锁

  > 全局锁的使用方法(是针对整个数据库的), 整个数据库只读, 应用场景: 全库的逻辑备份(为什么要只读, 因为若一个事务备份, 其他事务修改数据库, 在没有良好的隔离性的情况下会出问题)
  > 避免全局锁影响业务的方法: 可重复读隔离级别

- 表级锁 - 表级别的锁

  - 表级锁-表锁(分为共享锁-读锁和独占锁-写锁)
    这里是分会话(线程)的, 当x会话对a表加读锁, 所有会话都只能读a表, 包括x也只能读a, 不能写a, 同时x会话不能读写其他表

    > 允许当前会话读取被锁定的表，但阻止其他会话对这些表进行写操作。
    >
    > 允许当前会话对表进行读写操作，但阻止其他会话对这些表进行任何操作（读或写）。	

  - 表级锁-元数据锁MDL锁   - MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。
    CRUD加MDL读锁, 表结构变更加MDL写锁
    一个注意事项: 申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁, 一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。

  - 表级锁-意向锁  - 前提: InnoDB存储引擎
    记录的共享锁 则先加表级别的意向共享锁, 记录独占锁, 则先加表级别的意向独占锁
    因为表级别的锁是会和行级别的锁冲突的, 加表的独占锁, 需要判断是否有行级别的锁, 为了不遍历记录, 有一个意向锁来标识是否有行级锁就很方便
    **意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（*lock tables ... read*）和独占表锁（*lock tables ... write*）发生冲突。**

  - 表级锁-AUTO-INC锁(todo)    没看

- 行级锁  - InnoDB支持, MyISAM不支持
  - 行级锁-记录锁Record Lock 分读写锁, (事务给记录加锁
  - 行级锁-Gap Lock 只存在于可重复读隔离级别下, 目的是为了解决可重复读隔离级别下幻读的现象 不同事务的间隙锁之间不冲突
  - 行级锁-临键锁Next-Key Lock, 前两个的合体, 相同范围会冲突, 因为包含Record Lock
  - 行级锁-插入意向锁, 等待其他事务的间隙锁时产生的锁, 顾名思义. 
    插入意向锁名字虽然有意向锁，但是它并**不是意向锁，它是一种特殊的间隙锁，属于行级别锁**。
    不同事务可以同时拥有相同区间的间隙锁, 但是不能有同区间的插入意向锁和间隙锁

> 间隙锁锁住的 不可以插入, 删除和修改呢?
>
> 插入意向锁, 有读写属性吗, 可以多个事务同时拥有吗, 冲突吗

#### [MySQL 不同隔离级别，都使用了什么锁？ - 陈树义 - 博客园](https://www.cnblogs.com/chanshuyi/p/diff-trans-level-lock.html)

> 简短

- 说透MySQL锁机制

  > 对于 MySQL 来说，如果只支持串行访问的话，那么其效率会非常低。因此，为了提高数据库的运行效率，MySQL 需要支持并发访问。而在并发访问的情况下，会发生各种各样的问题，例如：脏读、不可重复读、幻读等问题。为了解决这些问题，就出现了事务隔离级别。
  >
  > 本质上，事务隔离级别就是为了解决并发访问下的数据一致性问题的。不同的事务隔离级别，解决了不同程度的数据一致性。而我们所说的**全局锁、表锁、行级锁等等**，其实都是**事务隔离级别的具体实现**。而 **MVCC、意向锁，则是一些局部的性能优化。**

- 读未提交
  读写操作可以同时进行，但写写操作无法同时进行。与此同时，该隔离级别下只会使用行级别的记录锁，并不会用间隙锁。

  > 如何得出的不会使用间隙锁: select for update在可重复读时会加间隙锁以防幻读, 但是这里不会
  
- 读已提交
  update是当前读, 要加锁, 两个事务并发update, 会阻塞
  
  可以看到还是只有一个行级别的记录锁，并没有间隙锁。  其实他们的最大区别，就是「读已提交」解决了脏读的问题。
  (这里的读写也可以同时进行, 使用read view)
  
- 可重复读
  总结一下：在「可重复读」隔离级别下，使用了记录锁、间隙锁、Next-Key三种类型的锁。(MySQL的可重复读解决了幻读问题)
  (读读可以, 读写的话, 也可以, 并且read view和版本链的帮助下, 实现了可重复读. 而写写是不可以的, 因为有行级别的记录锁. 另外使用了Next-Key解决了幻读)

  > 两个事务并发update, 当前读, 这里加了记录锁, 会阻塞(但是这里和update的列是不是索引是有关的)
  
- 总结

  > **对于任何隔离级别，表级别的表锁、元数据锁、意向锁都是会使用的**，但对于行级别的锁则会有些许差别。在「读未提交」和「读已提交」隔离级别下，都只会使用记录锁，不会用间隙锁(当然也不会有 Next-Key 锁了)。而对于「可重复读」隔离级别来说，会使用记录锁、间隙锁和 Next-Key 锁。

> MySQL的InnoDB才支持事务, MyISAM不支持
>
> 既然InnoDB支持行级锁, 就没必要用表锁. 且事务隔离级别就是为了解决事务并发访问时数据一致性问题的, 写写不可以并发, 而因为读未提交隔离级别很差, 所以读写可以并发, 也会造成脏读. 而本质上读已提交和可重复读为了解决脏读问题, 使用的是MVCC, 提高读写并发效率, 但是这里的前因后果, 必须要理清楚!!!  这里很重要

> update是当前读, 会加什么锁呢? select有当前读和快照读, 快照读不加锁, 而当前读还分两种, 一种加S型一种加X型, = =



[MySQL 是怎么加锁的？ | 小林coding](https://xiaolincoding.com/mysql/lock/how_to_lock.html)



### 死锁

![image-20250314203904059](C:\Users\yangzilong\Desktop\markdown\CS\MySQL\MySQL原理\image-20250314203904059.png)

#### [MySQL 死锁了，怎么办？ | 小林coding](https://xiaolincoding.com/mysql/lock/deadlock.html#死锁的发生)

- 死锁示例
  两个事务并发, select ... for update + insert就会死锁(前提是没有打开死锁检测)

  > 而for update是必须的, 如果用不加锁的快照读select, 两个事务并发就会出现重复的订单(这里的order_no不能重复, 但是又不是唯一二级索引, 所以必须使用加锁的当前读select语句)

- 为什么会产生死锁
  就是因为select for update这里加了X型的next-key锁, 范围是(1006, +∞], 后面两个事务再insert的时候, 插入意向锁和间隙锁冲突, 就会导致两个事务阻塞

  > 这里还和行锁的那些细节有关, 比如记录锁分S和X, 间隙锁不冲突, 而next-key是两者的组合, 所以也会冲突, 但是因为上面是+∞, 不是一个真实的记录, 所以不冲突
  >
  > 还要一个补充的点: 当查询的记录不存在时，加 next-key lock，然后会退化为间隙锁. 为什么上面事务 A 的 next-key lock 并没有退化为间隙锁？....

- Insert语句怎么加行级锁的?

  - Insert非冲突时会加隐式锁, 什么时候会转换为显式锁? 1. 间隙锁(防止幻读) 2. 唯一键冲突
  - 记录之间加有间隙锁
    间隙锁(或者next-key) 遇到insert时, insert的事务会生成一个插入意向锁, 并发生阻塞
  - 唯一键冲突(分为主键冲突和唯一二级索引列值冲突)
    1. 主键冲突, 插入新记录的事务会给已存在的主键值重复的聚簇索引记录**添加 S 型记录锁**。
    2. 唯一二级索引重复，插入新记录的事务都会给已存在的二级索引列值重复的二级索引记录**添加 S 型 next-key 锁**

- 唯一二级索引, 两个事务可重复读隔离级别下, insert语句的情况分析

  > 事务a, insert成功, 且为隐式锁
  >
  > 事务b, insert后, 事务 A 对 order_no 为 1006 记录加上了类型为 X 型的记录锁(隐式锁转换了) 同时事务 B 想对 order_no 为 1006 的记录加 S 型的 next-key 锁，但是由于事务 A 在该记录上持有了 X 型的记录锁，这两个锁是冲突的，所以导致事务 B 处于等待状态。(阻塞)

- 如何避免死锁

> 普通select不会对记录加锁的, 因为是通过MVCC机制实现的快照读, 若想加行锁, `select ... lock in share mode;`是对读取的记录加共享锁, `select ... for update;` 是对读取的记录加排他锁
>
> 行锁的释放时机是在事务提交（commit）后，锁就会被释放，并不是一条语句执行完就释放行锁。

#### [字节面试：加了什么锁，导致死锁的？ | 小林coding](https://xiaolincoding.com/mysql/lock/show_lock.html)

> 很简单, insert语句碰到了间隙锁, 所以间隙锁与插入意向锁冲突了

> 但是, `update t_student set score = 100 where id = 25;` 为什么加了间隙锁...



[悲观锁与乐观锁的实现(详情图解)_Java架构师迁哥_InfoQ写作社区](https://xie.infoq.cn/article/2085a95ad6b486d3905adc7d6)

> 不难, 不长

乐观锁与悲观锁 [数据库中的乐观锁与悲观锁 - murphy_gb - 博客园 (cnblogs.com)](https://www.cnblogs.com/kyoner/p/11318979.html)

> 不知道和上面那个是谁抄的谁的...

# 日志

### 三种日志分析

> binlog redo log区别?
>
> 为什么需要两阶段提交?
>
> 两阶段提交的过程?

[MySQL 日志：undo log、redo log、binlog 有什么用？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/mysql/log/how_update.html#为什么需要-undo-log)

> 总结 : 这个文章内容还挺多的, 基本上, 三个log为什么要有, 以及刷新策略, 作用都说了
>
> 分布式事务一致性协议  ????  **内部 XA 事务**  ????

- 为什么需要undo log?

  undo log 作用1: 实现事务回滚, 保障事务的原子性, 事务出现错误或用户执行rollback语句时利用undo log中的历史数据将数据恢复到事务开始之前的状态。
  undo log 作用2: 配合read view 实现MVCC(多版本并发控制) (从而控制并发事务访问同一个记录时的行为
  对于读提交 和 可重复读隔离级别, 它们的快照读（普通 select 语句）是通过 Read View + undo log 来实现的

  > 具体undo log内的日志格式以及内容暂略... trx_id 和 roll_pointer需要知道, 更新操作一定是记录版本链的, 其他暂略

- 为什么需要buffer pool(提高读写性能)

  > undo log 会写入 Buffer Pool 中的 Undo 页面。undo 页就是真正存储了 undo log

- 为什么需要redo log?

  - WAL技术(更新操作, 缓存页, 脏页的刷新, redo log日志, 这些之间是怎样进行配合的)

    > **WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上**。

  - redo log: 物理日志, 记录了某个数据页做了什么修改.

    > 在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。
    >
    > buffer pool中的undo页面的修改也需要记录到对应的redo log中(因为undo log需要持久化~)
  
  - redo log和undo log的对比    (!!!!!!!
  
  - 理解: redo log 要写到磁盘，数据也要写磁盘，为什么要多此一举？ 
    
    > 至此， 针对为什么需要 redo log 这个问题我们有两个答案：
    > **实现事务的持久性，让 MySQL 有 crash-safe 的能力**，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；
    > **将写操作从「随机写」变成了「顺序写」**，提升 MySQL 写入磁盘的性能。
    
  - redo log 什么时候刷盘? (这里的刷盘是指, 将缓存在内存中redo log buffer空间中的redo log持久化到磁盘中)
    几个时机...  另外, 针对innodb_flush_log_at_trx_commit 参数
    
    > 0: 每次事务提交, 不主动将redo log buffer中的redo log写入磁盘
    > 1: 每次事务提交, 都直接将..持久化到磁盘
    > 2: 每次事务提交, 都只是缓存在 redo log buffer 里的 redo log **写到 redo log 文件**(操作系统的文件缓存)
    >
    > 另外, InnoDB 的后台线程每隔 1 秒：
    > 针对参数 0: 调用write()把缓存在 redo log buffer 中的 redo log写到操作系统的Page cache, 再调用fsync()持久化到磁盘
    > 针对参数 2: 调用 fsync，将缓存在操作系统中 Page Cache 里的 redo log 持久化到磁盘
    >
    > 所以.........数据安全性和性能不可兼得, 用性能换取数据安全性
    
  - redo log文件组 & redo log写满了怎么办? (这里也进一步解释了WAL, 还有缓存页, 脏页是如何与redo log配合的)
  
    > 我们知道 redo log 是为了防止 Buffer Pool 中的脏页丢失而设计的
    > WAL, 也就是buffer pool中的脏页不急着更新到磁盘中, 先将redo log持久化即可保证数据的持久性

- 为什么需要bin log?

  > redo log是InnoDB存储引擎提供的,  bin log是mysql server层实现的
  >
  > redo log是物理日志, 追加写  bin log格式不定, 循环写(全量日志)
  >
  > redo log不能用于恢复整个数据库的数据(因为他是用来记录未被刷入磁盘的脏页数据的物理日志) 而bin log理论来说可以
  >
  > redo log用于掉电等故障恢复  binlog 用于备份恢复、主从复制

- 主从复制怎么实现的?  (...

- binlog什么时候刷盘?

  > 每个线程都有一片内存 - binlog cache  在事务提交的时候，执行器把 binlog cache 里的完整事务写入到 binlog 文件中，并清空 binlog cache。 
  >
  > 这里其实还是write + fsync, 和之前的redo log很像, 只是模型不太一样, 这里每个线程有自己 binlog cache，但是最终都写到同一个 binlog 文件
  >
  > sync_binlog 参数控制数据库的 binlog 刷到磁盘上的频率: 0 1 N, 依旧是用性能换取数据安全性

- 两阶段提交

  - 为什么需要两阶段提交?

    > 可以看到，在持久化 redo log 和 binlog 这两份日志的时候，如果出现半成功的状态，就会造成主从环境的数据不一致性。这是因为 redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。
    >
    > MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决

  - 两阶段提交的过程

    > 过程略
    >
    > 使用内部XA事务, 可以看到，**对于处于 prepare 阶段的 redo log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与 redo log 相同的** **XID**，如果有就提交事务，如果没有就回滚事务。这样就可以保证 redo log 和 binlog 这两份日志的一致性了。
    >
    > 所以说，**两阶段提交是以 binlog 写成功为事务提交成功的标识**，因为 binlog 写成功了，就意味着能在 binlog 中查找到与 redo log 相同的 XID。

  - 事务没提交的时候，redo log 会被持久化到磁盘吗？

    > 会的
    >
    > 事务执行过程中, 未提交前, 写操作就会利用WAL技术, 先写redo log, 后台线程每隔1s刷新一次(具体的刷新操作取决于innodb_flush_log_at_trx_commit参数)
    >
    > 但是这并不会造成问题, 因为事务未提交, bin log是不会持久化到磁盘的, 若事务未提交, mysql崩溃了, 重启后, 会利用undo log回滚, 且bin log还未持久化, 所以不会影响
    >
    > (其实redo log 和 bin log的刷新到磁盘的策略很像, 都由一个参数来控制具体策略, 但是redo log还有一个InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。)

  - 两阶段提交的问题

    1. 磁盘IO次数高(特别是双1配置下)
    2. 锁竞争激烈

- 组提交

  todo  到此为止吧, 如果有面经说到了这个再说

- MySQL 磁盘 I/O 很高，有什么优化的方法？

---

redo log vs change buffer



[14｜数据库事务：事务提交了，你的数据就一定不会丢吗？ | JUST DO IT (leeshengis.com)](https://leeshengis.com/archives/675812)

> 一向为神的leeshengis这次没有称神, 内容上来说, 基本上小林的就全覆盖了
>

[(十一)MySQL日志篇之undo-log、redo-log、bin-log.....傻傻分不清！ - 掘金 (juejin.cn)](https://juejin.cn/post/7157956679932313608#heading-1)

> 没看, 不想看, 小林就够了感觉

# 性能调优

### explain执行计划

explain是调优常用命令，需要掌握**如何分析—条SQL语句是否走了索引?**
**type、key、extra这三个字段，并理解其输出字段的含义。**

[136-EXPLAIN的概述与table、id字段剖析_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1iq4y1u7vj/?p=136&vd_source=894a223b85ae44e61e16dcd1a7356db0)

136 137 138

### 索引调优

有什么优化索引的方法

[索引常见面试题 | 小林coding](https://xiaolincoding.com/mysql/index/index_interview.html#什么是索引)

- 前缀索引优化 - 将大字符串字段的前几个字符建立索引

- 覆盖索引优化 - 减少回表

- 主键索引最好自增, 且长度不要太大

- 索引最好设置为NOT NULL

- 防止索引失效(之前文章学习过索引失效的场景)

  > 后面讲了如何通过explain执行计划显示的数据判断查询语句是否使用了索引。(type & extra)

### SQL优化

[Docs](https://ls8sck0zrg.feishu.cn/wiki/PrewwWYZuim5fmku88jcNFOTnyh)

[19 如何根治慢 SQL？](https://learn.lianglianglee.com/专栏/说透性能测试/19  如何根治慢 SQL？.md)

[(十七)SQL优化篇：如何成为一位写优质SQL语句的绝顶高手！写SQL不难，但写好SQL却并非易事，成为一名把业务SQL - 掘金](https://juejin.cn/post/7164652941159170078)

[无效回表谁的锅？存储引擎：这事儿不赖我](https://mp.weixin.qq.com/s?__biz=Mzg5ODU2ODczMQ==&mid=2247499167&idx=1&sn=f6510663e93d0c7e5154ea6f6bde0fde&chksm=c0623aebf715b3fd057755f1062d4a2656160f2beaf890db6b8228dc11837d2bd17e26c42666&token=1429342161&lang=zh_CN#rd)

[16 商品加入购物车：SQL优化和压力工具中的参数分析](https://learn.lianglianglee.com/专栏/高楼的性能工程实战课/16 商品加入购物车：SQL优化和压力工具中的参数分析.md)