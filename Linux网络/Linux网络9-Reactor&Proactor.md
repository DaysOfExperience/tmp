[Linux网络编程 | 事件处理模式：Reactor模式、Proactor模式_preactor 和 reactor linux_凌桓丶的博客-CSDN博客](https://oreki.blog.csdn.net/article/details/108928668?spm=1001.2014.3001.5502)

[如何深刻理解Reactor和Proactor？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/26943938/answer/1856426252)

# 网络IO模型的演进

1. **<u>对于每个连接，创建一个线程。</u>**

如果要让服务器服务多个客户端，那么最直接的方式就是为每一条连接创建线程。其实创建进程也是可以的，原理是一样的，进程和线程的区别在于线程比较轻量级些，线程的创建和线程间切换的成本要小些，为了描述简述，后面都以线程为例。

处理完业务逻辑后，随着连接关闭后线程也同样要销毁了，**但是这样不停地创建和销毁线程，不仅会带来性能开销，也会造成浪费资源，而且如果要连接几万条连接，创建几万个线程去应对也是不现实的。**

要怎么解决这个问题呢？我们可以使用「资源复用」的方式。

2. <u>**线程池，一个线程处理多个连接的业务。**</u>

也就是不用再为每个连接创建线程，而是创建一个「线程池」，将连接分配给线程，**然后一个线程可以处理多个连接的业务。**

不过，这样又引来一个新的问题，**线程怎样才能高效地处理多个连接的业务？**

当一个连接对应一个线程时，线程一般采用「read -> 业务处理 -> send」的处理流程，如果当前连接没有数据可读，那么线程会阻塞在 `read` 操作上（ socket 默认情况是阻塞 I/O），不过这种阻塞方式并不影响其他线程。

但是**引入了线程池，那么一个线程要处理多个连接的业务，线程在处理某个连接的 `read` 操作时，如果遇到没有数据可读，就会发生阻塞，那么线程就没办法继续处理其他连接的业务。**

要解决这一个问题，**最简单的方式就是将 socket 改成非阻塞**，然后**线程不断地轮询调用 `read` 操作来判断是否有数据**，这种方式虽然该能够解决阻塞的问题，但是解决的方式比较粗暴，因为**轮询是要消耗 CPU 的，而且随着一个线程处理的连接越多，轮询的效率就会越低。**

<u>**上面的问题在于，线程并不知道当前连接是否有数据可读，从而需要每次通过 `read` 去试探。**</u>

那有没有办法在只有当连接上有数据的时候，线程才去发起读请求呢？答案是有的，实现这一技术的就是 **I/O 多路复用**。

3. <u>**IO 多路复用**</u>

**I/O 多路复用技术会用一个系统调用函数来监听所有关心的连接，也就说<u>可以在一个监控线程里面监控很多的连接。</u>**（这么看其实和上方线程池有点像，因为也是一个线程处理多个连接，但是区别是**<u>IO多路复用技术下，线程不需要非阻塞轮询！而是当有数据需要处理时才会去处理。</u>**（包括新连接和连接的新数据）

我们熟悉的 select/poll/epoll 就是内核提供给用户的多路复用系统调用，线程可以通过一个系统调用函数从内核中获取多个就绪的事件。

select/poll/epoll 是如何获取网络事件的呢？

在获取事件时，先把我们要关心的连接传给内核，再由内核检测：

- 如果没有事件发生，线程只需阻塞在这个系统调用，而无需像前面的线程池方案那样轮询调用 read 操作来判断是否有数据。

- 如果有事件发生，内核会返回产生了事件的连接，线程就会从阻塞状态返回，然后在用户态中再处理这些连接对应的业务即可。

> **当下开源软件能做到网络高性能的原因就是 I/O 多路复用吗？**
>
> 是的，基本是基于 I/O 多路复用，用过 I/O 多路复用接口写网络程序的同学，肯定知道是面向过程的方式写代码的，这样的开发的效率不高。于是，大佬们基于面向对象的思想，对 I/O 多路复用作了一层封装，让使用者不用考虑底层网络 API 的细节，只需要关注应用代码的编写。

大佬们还为这种模式取了个让人第一时间难以理解的名字：**Reactor 模式**。

Reactor 翻译过来的意思是「反应堆」

这里的反应指的是「**对事件反应**」，也就是**来了一个事件，Reactor 就有相对应的反应/响应**。

事实上，Reactor 模式也叫 **`Dispatcher` 模式**，这个名字更贴合该模式的含义，即 **通过I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程去处理事件**。

<u>**（通过IO多路复用 对所有连接的各种事件进行监控，如果有事件就绪，则dispatch分配给某个线程/进程进行处理）**</u>

Reactor 模式主要由 **Reactor 和 处理资源池** 这两个核心部分组成，它俩负责的事情如下：

- **Reactor 负责监听和分发-dispatch事件**，事件类型包含连接事件、读写事件；
- **处理资源池负责处理事件**，如 read -> 业务逻辑 -> send；

Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于：

- Reactor 的数量可以只有一个，也可以有多个；
- 处理资源池可以是单个进程 / 线程，也可以是多个进程 /线程；

将上面的两个因素排列组合一下，理论上就可以有 4 种方案选择：

- 单 Reactor 单进程 / 线程；（只有一个线程，既是Reactor线程，又是处理资源池线程。也就是获取事件之后，交给自己处理）
- 单 Reactor 多进程 / 线程；（一个Reactor线程，多个处理资源池线程。）
- 多 Reactor 单进程 / 线程；（多个Reactor线程，一个处理资源池线程。）
- 多 Reactor 多进程 / 线程；（多个Reactor线程，多个处理资源池线程。）

其中，「多 Reactor 单进程 / 线程」实现方案相比「单 Reactor 单进程 / 线程」方案，不仅复杂而且也没有性能优势，因此实际中并没有应用。

剩下的 3 个方案都是比较经典的，且都有应用在实际的项目中：

- 单 Reactor 单线程 / 进程；
- 单 Reactor 多线程 / 进程；
- 多 Reactor 多线程 / 进程；

方案具体使用进程还是线程，要看使用的编程语言以及平台有关。

# 单 Reactor 单线程 / 进程

> 其实下面的Acceptor和Handler可以理解为一个模块, 都是对就绪的事件进行响应/处理, 只是有的是对listen套接字的事件进行处理, 有的是对TCP连接套接字的事件进行处理
>
> 核心在于, 整个都是在一个线程里面进行的, 也就是epoll_wait之后, 获取若干事件, 然后处理所有事件(两个种类), 再循环epoll_wait进行处理

![image-20231207155117585](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231207155117585.png)

可以看到进程里有 **Reactor、Acceptor、Handler** 这三个对象：

- Reactor 对象的作用是监听和分发事件；
- Acceptor 对象的作用是获取连接；
- Handler 对象的作用是处理业务；

对象里的 select、accept、read、send 是系统调用函数，dispatch 和 「业务处理」是需要完成的操作，其中 dispatch 是分发事件操作。

接下来，介绍下「单 Reactor 单进程」这个方案：

- Reactor 对象通过 epoll （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；
- 如果是**连接建立的事件**，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法获取连接，并创建一个 Handler 对象来处理后续的响应事件；
- 如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；
- Handler 对象通过 read -> 业务处理 -> send 的流程来完成完整的业务流程。

**单 Reactor 单进程的方案因为全部工作都在同一个进程内完成，所以实现起来比较简单，不需要考虑进程间通信，也不用担心多进程竞争。**

但是，这种方案存在 2 个缺点：

- 第一个缺点，因为只有一个进程，**无法充分利用 多核 CPU 的性能**；
- 第二个缺点，Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，**如果业务处理耗时比较长，那么就造成响应的延迟**；

所以，单 Reactor 单进程的方案**不适用计算机密集型的场景(业务处理复杂)，只适用于业务处理非常快速的场景**。

<u>Redis 是由 C 语言实现的，它采用的正是「单 Reactor 单进程」的方案，因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 Redis 对于命令的处理是单进程的方案。</u>

# 单 Reactor 多线程 / 进程

如果要克服「单 Reactor 单线程 / 进程」方案的缺点，那么就需要引入多线程 / 多进程，这样就产生了**单 Reactor 多线程 / 多进程**的方案。

闻其名不如看其图，先来看看「单 Reactor 多线程」方案的示意图如下

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230910121131013.png" alt="image-20230910121131013" style="zoom:67%;" />

详细说一下这个方案：

- Reactor 对象在主线程中通过 epoll（IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；
- 如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法获取连接，并创建一个 Handler 对象来处理后续的响应事件；
- 如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；

上面的三个步骤和单 Reactor 单线程方案是一样的，接下来的步骤就开始不一样了：

- **Handler 对象不再负责<u>业务处理</u>，只负责数据的接收和发送(网络IO)，Handler 对象通过 read 读取到数据后，会将数据发给<u>子线程进行业务处理</u>；**
- **子线程里的 Processor 对象就进行业务处理，处理完后，将结果发给主线程中的 Handler 对象(线程间通信/进程间通信)，接着由 Handler 通过 send 方法将响应结果发送给 client；**

（也就是线程池内的worker线程仅用于进行业务处理，新连接的accept以及某连接的新数据的收以及业务处理结果的发都是由主线程-Reactor线程来完成）

单 Reactor 多线程的方案优势在于**能够充分利用多核 CPU 的能力**，那既然引入多线程，那么自然就带来了多线程竞争资源的问题。

例如，子线程完成业务处理后，要把结果传递给主线程的 Reactor 进行发送，这里涉及共享数据的竞争。

> 要避免多线程由于竞争共享资源而导致数据错乱的问题，就需要在操作共享资源前加上[互斥锁](https://www.zhihu.com/search?q=互斥锁&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1856426252})，以保证任意时间里只有一个线程在操作共享资源，待该线程操作完释放互斥锁后，其他线程才有机会操作共享数据。
>
> 聊完单 Reactor 多线程的方案，接着来看看单 Reactor 多进程的方案。
>
> 事实上，单 Reactor 多进程相比单 Reactor 多线程实现起来很麻烦，主要因为要考虑子进程 <-> 父进程的双向通信，并且父进程还得知道子进程要将数据发送给哪个客户端。
>
> 而多线程间可以共享数据，虽然要额外考虑并发问题，但是这远比进程间通信的复杂度低得多，因此实际应用中也看不到单 Reactor 多进程的模式。

另外，「单 Reactor」的模式还有个问题，**因为一个 Reactor 对象承担所有事件的监听和响应，而且只在单个主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方**。重点：一个Reactor线程承担所有事件的监听和响应！

# 多 Reactor 多进程 / 线程

要解决「单 Reactor」的问题，就是将「单 Reactor」实现成「多 Reactor」，这样就产生了 **多 Reactor 多进程 / 线程**的方案。

多 Reactor 多进程 / 线程方案的示意图如下（以线程为例）：

> 主线程: 只监听listen套接字, 获取到新的连接后, 分发给若干子线程, 而一个子线程可能会处理多个连接, 采用的依旧是epoll多路复用模式, 这样后续某连接的读事件监听, 读取数据, 业务处理, 发送数据, 都是由子线程完成的
>
> 主线程仅负责listen套接字的监听, 新连接的获取
>
> 子线程负责网络连接的后续全部过程

![image-20230910121649382](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230910121649382.png)

方案详细说明如下：

- 主Reactor线程通过 epoll 监控连接建立事件(只监听listen套接字)，收到事件后通过  accept 获取连接，将新的连接分配给某个子线程；
- 子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入 epoll 继续进行监听，并处理连接的响应事件。
- 如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。
- Handler 对象通过 read -> 业务处理 -> send 的流程来完成完整的业务流程。

多 Reactor 多线程的方案虽然看起来复杂的，但是实际实现时比单 Reactor 多线程的方案要简单的多，原因如下：

- **主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成连接后续的业务处理。**
- **主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。**

大名鼎鼎的两个开源软件 Netty 和 Memcache 都采用了「多 Reactor 多线程」的方案。

采用了「多 Reactor 多进程」方案的开源软件是 Nginx，不过方案与标准的多 Reactor 多进程有些差异。

具体差异表现在主进程中仅仅用来初始化 socket，并没有创建 mainReactor 来 accept 连接，而是由子进程的 Reactor 来 accept 连接，通过锁来控制一次只有一个子进程进行 accept（防止出现惊群现象），子进程 accept 新连接后就放到自己的 Reactor 进行处理，不会再分配给其他子进程。
