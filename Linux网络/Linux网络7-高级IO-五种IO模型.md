# 如何理解IO

网络通信的本质就是IO，发送端发数据是output，接收端接收数据就是input。（发送端也可以接收 input，接收端也可以发送 output）

> 一端发送, 其实数据包发送的过程接收端无法控制, 在传输过程中是不能被优化的, 接收端的机器从物理层到应用层的解包也是不能优化的
>
> 所以, 其实接收端只能等待数据到来, 到来之后再从内核拷贝到应用层

IO的效率问题：IO的效率底下，有两个原因。

第一个效率低的原因：

网络IO，磁盘IO都要访问硬件外设，比如网络IO要访问网卡，磁盘IO要访问磁盘。使得IO效率低。

第二个效率低的原因：

调用recv时，如果接收缓冲区没数据可供读取，会怎样？等。而接收缓冲区有数据就绪时，就会进行数据拷贝。

调用send时，如果发送缓冲区没空间可供发送，会怎样？等。等待发送缓冲区有空间了，进行数据拷贝。

**这里的等就是阻塞。**

**所以，IO  = 阻塞式的等待 + 数据拷贝。**

低效IO：单位时间的大部分时间内，IO类的接口都在等。高效IO：单位时间，等的比重降低。

# IO模型

**根据各自的特性不同**，IO模型被分为阻塞IO、非阻塞IO、信号驱动IO、异步IO、多路复用IO五类。
**最主要的两个区别就是阻塞与非阻塞，同步与异步。**

### 阻塞与非阻塞

阻塞与非阻塞最主要的区别就是**程序在等待调用结果时的状态。**

阻塞：为了完成一个功能发起调用，**如果不具备完成功能的条件，调用会一直等待**
非阻塞：为了完成一个功能发起调用，**如果不具备完成功能的条件，则立即报错返回**

阻塞IO: 在内核将数据准备好之前, 系统调用会一直等待. 所有的套接字, 默认都是阻塞方式
非阻塞IO: 如果内核还未将数据准备好, 系统调用仍然会直接返回, 并且返回EWOULDBLOCK错误码

阻塞调用是指调用结果返回之前, 当前线程会被挂起, 调用线程只有在得到结果之后才会返回
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程，而是错误返回

调用一个方法，

阻塞IO为：**如果条件不就绪，就一直阻塞等待条件就绪。**
非阻塞IO为：**如果条件不就绪，直接报错返回。**

### 同步与异步

同步与异步最主要的区别就是

1. 功能完成的流程是否是顺序化的
2. 完成的是自身还是系统。

同步：功能完成的**流程是顺序化**的，并且**功能由自身完成。**
异步：功能完成的**流程是不确定**的，并且**功能由系统完成。**

所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回. 但是一旦调用返回，就得到返回值了; (非阻塞的错误返回也是返回，所以非阻塞IO的调用也是同步的)

异步则是相反，**调用在发出之后，这个调用就直接返回了，并且没有返回结果**; 换句话说，当一个异步过程调用发出后，**调用者不会立刻得到结果;** 而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用

同步：发起一个调用，返回时一定有了结果。

异步：发起一个调用，不会立刻获取结果。等待其他人（通常是OS）把这个任务执行完，有了结果再通知调用发起者。

## 阻塞IO

**发起IO调用，如果不具备IO条件，则一直等待直到条件就绪。**

![image-20231121135659707](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231121135659707.png)

> 左边：进程阻塞, 其实就是阻塞式的等待，等待资源就绪，然后进行阻塞式的拷贝数据。而等+拷贝都是由这个进程自己进行的。所以是同步。这个过程是顺序化的， 并且是由进程自己完成的。

优点：简单

缺点：**任务处理效率较低**，无法充分利用资源。

## 非阻塞IO

发起一个IO调用，如果不具备IO条件，则**立即报错返回**，执行其他代码。通过一个循环来不断发起IO请求，直到条件就绪则进行数据拷贝。

![image-20231121135900906](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231121135900906.png)

> 等+拷贝都是进程自己做的, 所以属于同步IO。只是如果资源不就绪就直接报错返回，等待时可以做其他事情，不会阻塞式的等待。这就是非阻塞！

优点：与阻塞IO相比较来说，利用了等待的时间去做了其他的事情，**对资源的利用更加充分**。

缺点：

1. 与阻塞IO对比，**IO调用需要循环发起，流程更加复杂。**
2. 如果IO条件就绪了，也要等待上一轮循环结束后进入当前循环，才能进行处理，这就导致了**IO可能不够实时。**

3. 非阻塞IO往往需要循环的方式反复尝试读写文件描述符, 这个过程称为轮询. **这对CPU来说是较大的浪费**, 因此一般只有特定场景下才使用.

---

**非阻塞IO可以通过`fcntl`函数设置描述符状态来实现**

```C++
void SetNoBlock(int fd) 
{
	int flag = fcntl(fd, F_GETFL, 0);
	
	flag |= O_NONBLOCK;
	fcntl(fd, F_SETFL, flag);
}
```

## 信号驱动IO

信号驱动IO: 内核将数据准备好的时候, 使用SIGIO信号通知应用程序进行IO操作.

自定义一个IO就绪的信号，**当资源就绪时OS就发出这个信号给进程**。在没有收到信号时，可以继续处理其他事情，一旦收到信号，就会中断当前操作，来优先处理IO事件。

![image-20231121140400316](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231121140400316.png)

非阻塞IO是轮询式进行系统调用, 判断条件是否满足, 而信号驱动IO是让OS在条件满足时通过信号的方式通知进程

拷贝的工作都是由进程完成的, 非阻塞和信号驱动都是在条件不就绪时可以做其他事情, 都属于同步IO

优点：

1. **相较于非阻塞IO**，因为信号到来后就直接强行中断进行处理，**更加实时**。
2. 在没收到信号的时候可以执行其他工作，**资源利用更加充分**。

缺点：因为需要自定义信号，又要有主控流程也要有信号处理流程，并且还需要考虑信号是否可靠导致的事件丢失情况，**流程会更加的复杂。**

## 多路复用IO

多路复用IO, **对大量的IO事件进行监控，能够让用户只针对就绪了指定事件（可读、可写、异常） 的IO(描述符)进行IO操作**。避免了阻塞，提高了效率。

Linux操作系统提供了三种IO多路转接模型：**select模型、poll模型、epoll模型**。根据不同的多路复用模型，具体的优缺点也不一样。

![image-20231121140829142](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231121140829142.png)

IO多路转接: 从流程图上看起来和阻塞IO类似. 实际上IO多路转接的核心在于**能够同时等待多个文件描述符的就绪状态**

过程和阻塞IO很像, 先阻塞等待, 等待条件/资源就绪则进行拷贝操作, 等待+拷贝都是由进程自己完成的, 所以属于同步IO

最大的特点和优势是可以同时对大量套接字的IO事件进行监控，哪个套接字的事件就绪则处理哪个套接字的对应事件, 单线程就可以完成这个工作。

## 异步IO

异步IO: 由内核在数据拷贝完成时通知应用程序(而信号驱动IO是通过信号通知应用程序可以开始拷贝数据, 拷贝工作是由进程自己完成)

IO处理的顺序不确定，**整个IO的过程（等待 + 数据拷贝）由操作系统来完成而并非用户。**最大的不同：等待条件就绪 + 数据拷贝都是由OS完成而不是进程自己。所以这就是异步的。

![image-20231121141713662](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231121141713662.png)

流程 : 

1. 自定义一个 IO完成信号
2. 发起异步调用后返回，此时用户进程可以处理其他事情
3. 系统进行IO事件的等待以及数据拷贝
4. IO完成后通过信号通知进程

**优点：对资源的利用最为充分, 以最高的效率进行任务的处理**

**缺点：资源消耗较高, 流程最为复杂**

---

**上面的五种IO模型，从前往后处理的效率逐渐增加，对资源的利用也逐渐充分，但是流程也越来越复杂。**