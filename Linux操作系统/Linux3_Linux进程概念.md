# 3_Linux进程概念

## 进程

### 进程的基本概念

**程序：一系列有序的指令集合（就是我们写的代码）
进程：进程就是程序的一次执行，是系统进行资源分配和调度的独立单位。**

**进程是正在运行的程序的实例**（an instance of a computer program that is being executed）

**程序是一个没有生命的实体，只有操作系统执行它时，它才能成为一个活动的实体，也就是进程。同时，操作系统通过进程控制块(PCB)，来对程序进行调度使用**

内核观点：**承担分配系统资源（CPU时间，内存）的实体/基本单位。**

### 描述进程 - PCB

> **CPU分时机制：通过极快的速度切换和调度运行所有的程序，造成了同时运行的假象。**
>
> 但是，这里还存在着几个问题，CPU是如何在内存中找到每个程序的？CPU在来回调度时，如何能够从上一次运行的位置继续运行？如何能够保证继续处理上一条没有处理完的数据？
>
> 所以操作系统为了能够完成这些操作，设置了一个用于描述进程信息的数据结构，也就是我们通常所说的PCB。

PCB ：Process Control Block 进程控制块  PCB（进程控制块）**是操作系统用来管理和维护进程信息的数据结构**  用于描述进程

**作用 : 用于描述操作系统中的进程, PCB是操作系统对一个运行中的程序(也就是进程)的描述，操作系统通过这个描述来实现对程序的运行调度**

操作系统正是通过一个一个的PCB来对运行中的程序进行调度使用。CPU通过PCB中的内存指针来找到程序在内存中的地址，通过上下文数据来记录运行中程序的各种信息，通过程序计数器来找到这个程序即将执行的下一条指令的地址。

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231116133628457.png" alt="image-20231116133628457" style="zoom:50%;" />

#### 为什么要有PCB？PCB的作用？

> 其实上面已经说了, 就是描述进程

> 六个字：先描述，再组织。  这是一个管理的观念，比如我们写C++程序时，写的类就是为了描述某一个事物，而创建了类的实例化对象之后，用某一个数据结构将其组织起来，就叫做再组织。之后再使用某些算法就可以达到管理对象。 这个观念在程序开发和很多场景下都适用，而C++中的STL就是为了帮助我们更方便地组织实例化对象。

所以，在操作系统中，进程也是一个事物，**操作系统要管理进程**，那么最好的方法就是**先描述，再组织**。**而描述，采用的方法就是利用一个strcut去存储进程的各种属性来描述进程。之后再在内存中，用数据结构将这些PCB（结构体）组织起来，来达到更好地管理进程的目的。**

#### task_struct - Linux下的PCB

在Linux操作系统中，描述进程的结构体叫做task_struct，Linux的PCB名为task_struct。

> 它们的关系就像是：警察是一种职业，task_struct是一种PCB。

task_struct是Linux内核的一种数据结构，它会被装载到RAM(内存)里并且包含着进程的信息。

#### task_ struct内容分类

标示符: 描述本进程的唯一标示符，用来区别其他进程。 
**状态**: 任务状态，退出代码，退出信号等。 
**优先级**: 相对于其他进程的优先级。 
**程序计数器**: 程序中即将被执行的下一条指令的地址。
**内存指针**: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针 
**上下文数据**: 进程执行时处理器的寄存器中的数据[休学例子，要加图CPU，寄存器]。 
I／O状态信息: 包括显示的I/O请求,分配给进程的I／O设备和被进程使用的文件列表。 
记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。 
其他信息

> PID/PPID - 进程标示符
>
> 每个进程都有一个ID，PID就类似于人的身份证号码。而PPID是该进程的父进程的PID。
>
> pid_t getpid(void)     get process id      pid_t getppid(void)     get parent process id   (系统调用函数)
>
> 这两个函数是系统调用函数，并不是C/C++库函数，其实属于是操作系统提供的库函数。 pid_t本质上是一个int
>
> ![image-20231115163845387](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231115163845387.png)
>
> bash：一种shell，是Linux下的命令行解释器，我们执行命令，./运行可执行程序都是bash通过创建子进程的方式进行的。

### Linux下通过命令查看进程的方式

- **top** 

Linux下的任务管理器，通常用来查看资源占用比较高的进程。对于查看某个进程的具体信息数据，使用ps更方便。

- ps

ps -axj **表示查看所有进程，第一行是对应的下面的属性的名称。**

> ps -ajx | head -1 && ps -ajx | grep process_name
>
> 左边表示，打印出ps后的第一行，即属性名。右边表示ps后过滤出指定的进程。
>
> 我们在右边运行process可执行程序，左边利用ps查询出对应进程。
>
> 第二行 grep --color=auto process 是用grep工具过滤process这个进程，它在操作系统中本质上也是一个进程。
>
> <img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231115162825492.png" alt="image-20231115162825492" style="zoom:67%;" />
>
> while :; do ps axj | head -1 && ps ajx | grep myproc | grep -v grep; sleep 1; done  循环进行ps查看进程，用于实时监控某个进程的信息。

- /proc /proc

是Linux系统下的一个目录，存储着所有进程的信息。以每个进程的PID作为目录名来标识每个进程。

> /proc目录是一个动态的目录，当一个进程运行结束后，在该目录内就会删除此进程的目录文件。
>
> <img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231115163219535.png" alt="image-20231115163219535" style="zoom:50%;" />
>
> ls /proc/5441表示查看proc目录下名为5441目录的内容，其中存储的就是PID为5441进程的所有属性信息。
>
> <img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231115163736674.png" alt="image-20231115163736674" style="zoom:50%;" />
>
> 其他属性我们可能暂时不认识，但是，cwd表示当前工作目录，Current working directory。也就是这个进程所在的目录（其实就是可执行程序所在的目录）   exe表示可执行程序的具体位置：/home/yzl/202283dir/process  。其他属性暂时略了。

### 通过系统调用创建进程-fork

fork是一个操作系统接口函数，作用是创建子进程。fork函数，用于创建子进程，返回值是pid_t，如果创建子进程成功，则返回给父进程子进程的PID，返回给子进程0。如果创建子进程失败，则返回给父进程-1，errno被恰当地设置。

```C++
  1 #include<stdio.h>
  2 #include<unistd.h>
  3 #include<stdlib.h>
  4 #include<sys/types.h>
  5 
  6 int main()
  7 {
  8     printf("I am parent process!\n");
  9 
 10     pid_t ret = fork();
 11 
 12     if(ret < 0)
 13     {
 14         perror("fork");
 15         return -1;
 16     }
 17     else if(ret == 0)
 18     {
 19         // child process
 20         // 子进程会执行这段代码
 21         while(1)
 22         {
 23             printf("I am child process, fork_ret:%d, pid:%d, ppid:%d\n",ret,getpid(),getppid());
 24             sleep(1);
 25         }
 26     }
 27     else{
 28         // parent process
 29         // 父进程会执行这段代码
 30         while(1)
 31         {
 32             printf("I am father process, fork_ret:%d, pid:%d, ppid:%d\n",ret,getpid(),getppid());                                                                                                            
 33             sleep(1);
 34         }
 35     }
 36 
 37     return 0;
 38 }       
```

![image-20231115164122000](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231115164122000.png)

> 在fork函数内部，主体代码肯定是创建子进程，而return的时候，子进程已经创建出来了，那么，哪个进程先执行return呢？ 其实这个是不确定的。因为CPU执行一个进程的代码，是执行上若干时间，再换其他进程。只是这个若干时间非常非常小，并且速度非常块，凭人的主观意识感觉到的好像是多个进程同时执行。   所以，到底哪个进程先执行return是不确定的。这个是由操作系统的调度器决定的。

**在子进程创建的时候，它从父进程的PCB中复制了很多数据，如内存指针、上下文数据、程序计数器等，所以它的代码、数据以及运行的位置，都与父进程一模一样。**

父子进程代码共享(只读, 不可修改)，数据相互独立(采用写时拷贝技术)

> fork之后发生了什么？父子进程的资源如何划分？
>
> bash的作用，与shell的关系，工作原理???
>
> 写时拷贝???

## 进程状态

进程状态本质也是PCB中的一个字段。

### 操作系统中的进程状态

**新建**：指的是进程刚被创建好，还没有被CPU调度的状态，事实上，Linux下并没有这种状态，而操作系统中有此状态也是为了整体更加严谨，完善。
**运行**：进程的task_struct被CPU调度或者在CPU的runqueue（运行队列）中等待被调度，都称为运行态（另一种说法是，被CPU调度为运行态，在运行队列中是就绪态）
**阻塞**：<u>等待非CPU资源就绪的状态</u>，例1，比如要进行文件读取，在硬盘的执行队列中等待硬盘的响应，就是阻塞状态。 例2，scanf时等待键盘的输入，也是阻塞状态，其实这个的场景还是非常多的。
**挂起**：类似于阻塞，情景比较少见，比较极端。当内存不足时，OS会置换长期不运行的进程的代码和数据到磁盘，而内存中只留进程的PCB，此时进程被称为挂起状态。
**退出**：进程结束的状态。

### Linux操作系统：进程状态

![image-20231115131213297](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231115131213297.png)

#### R 运行状态（running）

并不意味着进程一定在运行中(CPU执行进程代码)，它表明进程要么是在运行中要么在运行队列里。对应上方的运行态。

> 只运行死循环即可，但是前提是，循环内不可以有打印语句。

#### S 睡眠状态 (sleeping)

意味着<u>进程在等待非CPU资源的就绪</u>（有时候也叫做可中断睡眠，（interruptible sleep））。
当while循环不断printf时，显示的是睡眠状态，这里可能并不是我们所预料的，因为看上去这个进程一直在运行，事实上显示睡眠态的原因是，可能这个进程等待显示器等其它资源就绪的时间比上CPU执行的时间可能是50：1，也就是CPU的执行速度是非常快的，大多数时间都是等待显示器的资源就绪。（当一直查看这个进程状态时，少数会显示出R）   （对应的就是上方的阻塞状态）

#### D磁盘休眠状态（Disk sleep）

有时候也叫不可中断睡眠状态（uninterruptible sleep），在这个状态的 进程通常会等待IO的结束。
可以理解为，有些进程当在和磁盘进行数据读写时（IO），不可以被中断，因为意外中断可能导致数据丢失等问题。

#### T停止状态（stopped）

可以通过发送 19号信号 SIGSTOP 给进程来停止（T）进程。这个被暂停的进程可以通过发送 SIGCONT 信号让进程继续运行。

#### t 停止状态(tracing stop) 

本质上也是暂停状态，只是如果使用gdb调试某进程，并使进程在某断点处停下，进程就处于t状态，而本质上，断点就是程序在运行到某一行处时暂停了。

#### X死亡状态（dead）

这个状态只是一个返回状态，瞬时性非常强，你不会在任务列表里看到这个状态。它仅表示此进程已结束，告知OS，这个进程的数据可以回收了。

#### Z(zombie)-僵尸状态，僵尸进程

**当子进程退出并且父进程没有读取子进程退出码时子进程就是一个僵死(尸)进程**
僵死进程会以终止状态保持在进程表中，并且会一直在等待父进程读取退出状态代码。 所以，只要子进程退出，父进程还在运行，但父进程没有读取子进程状态，子进程即进入Z状态。

> 事实上，每个进程正常退出时，都会经历很小的一段僵尸状态，这段时间内等待父进程读取这个子进程的退出码。

僵尸进程危害: 父进程一直不读取子进程状态，子进程的Z状态就会一直维持下去。子进程Z状态一直不退出，这个进程的PCB就一直要维护。如果永远不回收，就会造成**内存泄漏**，因为PCB就会一直存在于内存中，不被释放。

#### 僵尸进程如何避免？

1. 进程等待: 父进程通过调用wait/waitpid来读取子进程退出码以及回收子进程资源。

2. 退出父进程

#### 孤儿进程

子进程退出，父进程不读取子进程的状态。子进程为僵尸进程。
父进程退出，子进程变成孤儿进程。那么，如果这个进程不被领养，则此子进程退出后就会变成僵尸进程，且永远不会被释放内存导致**内存泄漏**。所以，子进程必须被领养，且是被1号进程领养。当子进程退出后，就会由新的父进程：1号进程回收这个子进程。

#### 守护进程（精灵进程）

守护进程：**一种特殊的孤儿进程**，父进程是一号进程，**运行在后台，与终端和登陆会话脱离关系，不受影响。**

守护进程通常是一种运行在系统后台的批处理程序，默默的做一些循环往复的事情

## 程序地址空间（虚拟地址空间）

虚拟地址空间的引出：

```C++
  1 #include<stdio.h>
  2 #include<unistd.h>
  3 int g_val = 100;
  4 
  5 int main()
  6 {
  7     pid_t id = fork();
  8     if(id == 0)
  9     {
 10         // 子进程
 11         int i = 0;
 12         while(1)
 13         {
 14             printf("I am child process, id:%d, g_val:%d, &g_val:%p\n", getpid(), g_val, &g_val);
 15             i++;
 16             if(i == 5)
 17             {
 18                 g_val = 200;
 19                 printf("Child process changed g_val success!!!\n");
 20             }
 21             sleep(1);                                                                                                                                                                                        
 22         }
 23     }
 24     else {
 25         while(1)
 26         {
 27             printf("I am parent process, id:%d, g_val:%d, &g_val:%p\n", getpid(), g_val, &g_val);
 28             sleep(1);
 29         }
 30     }
 31     return 0;
 32 }
```

```C++
[yzl@VM-4-5-centos tmp]$ ./proc
I am parent process, id:28298, g_val:100, &g_val:0x601054
I am child process, id:28299, g_val:100, &g_val:0x601054
I am parent process, id:28298, g_val:100, &g_val:0x601054
I am child process, id:28299, g_val:100, &g_val:0x601054
I am child process, id:28299, g_val:100, &g_val:0x601054
I am parent process, id:28298, g_val:100, &g_val:0x601054
I am parent process, id:28298, g_val:100, &g_val:0x601054
I am child process, id:28299, g_val:100, &g_val:0x601054
I am parent process, id:28298, g_val:100, &g_val:0x601054
I am child process, id:28299, g_val:100, &g_val:0x601054
Child process changed g_val success!!!
I am parent process, id:28298, g_val:100, &g_val:0x601054
I am child process, id:28299, g_val:200, &g_val:0x601054
I am parent process, id:28298, g_val:100, &g_val:0x601054
I am child process, id:28299, g_val:200, &g_val:0x601054
```

上述代码为，创建子进程，若干秒后，子进程改变全局变量值，发现子进程与父进程打印此全局变量值时，值不同，且地址相同。

同一个地址处的值在同一时刻不可能不同，于是引出了[虚拟地址](https://so.csdn.net/so/search?q=虚拟地址&spm=1001.2101.3001.7020)空间的概念。即这里子进程与父进程打印的地址并非实际的物理地址，而是一种虚拟地址（线性地址）。

### Linux下进程虚拟地址空间分布

**虚拟地址空间使得每个进程看待内存时都有一个统一的视角**，并且在他们看来，**内存的分布是井然有序的。**

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231115131651175.png" alt="image-20231115131651175" style="zoom:67%;" />

注：初始化数据和未初始化数据是全局数据区，这里存储的都是全局的初始化/未初始化数据。正文代码的内部的高地址处有一小段的字符常量区。这块数据（正文代码）都是只读的。

1. 栈堆相向增长，堆向高地址增长，栈向低地址增长。这两个区域是动态变化的。
2. 虚拟地址空间分为两个空间：1. 内核空间，在32位下占1G   2. 用户空间，在32位下占3G
   即[0, 3GB] 用户空间    [3GB, 4GB] 内核空间
3. static修饰局部变量，本质上是将此变量属性变为全局属性，存储在全局区。而语法的限制使得此static变量仅能在局部可见。
4. 上图虚拟内存分布仅适用于Linux操作系统，不适于Windows。
5. 一个有关堆区的知识：当C语言使用malloc函数时，申请10字节空间，实际在内存中会占用大于10字节的空间，多出的空间用于存储一些属性。这也是为什么free时传首地址即可，而不需要传空间大小。

### 什么是虚拟地址空间？（灵魂拷问

**是一个mm_struct结构体，属于进程的内核数据结构，用于操作系统向进程描述一个完整的连续的线性地址空间。**

在Linux下，进程地址空间是一个名为mm_struct的结构体，主要存储各区域（堆，栈，全局数据区，只读代码区等）的范围，即start和end，用于划分各个区域。

**页表**是和虚拟地址空间结构体mm_struct配套的内核数据结构，页表的作用是：将虚拟地址映射到物理地址。即起一个映射配对的作用。   因为实际上数据，代码，变量等肯定最终要存储在物理内存中。(页表起映射作用，就类似于C++中的map数据结构，key 是虚拟地址， value是对应的物理地址)

因此, 每一个进程都有一份地址空间结构体变量mm_struct和页表实例化对象。

> 虚拟地址出现之前：进程直接访问物理内存
>
> 在早期计算机操作系统内部，进程直接访问物理内存。这样做有很多弊端。在说弊端之前，有一个点需要明确：内存本身是可以随意读写的，物理内存是不存在只读的情况的。
> 比如，最典型的野指针问题，一个进程的野指针很容易破坏其他进程，甚至影响操作系统内的安全数据。其次，进程直接访问物理内存，使得进程和物理内存耦合度很大，内存管理变得不方便，从而内存碎片等问题也变得更难处理。
> 基于进程直接访问物理内存的弊端，衍生出虚拟地址空间。

![image-20231115132146801](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231115132146801.png)

> PCB中有一个struct mm_struct* mm指针数据成员指向这个进程对应的mm_struct结构体（进程地址空间）

虚拟地址空间结构体是如何进行区域划分的呢？
通过定义栈区，堆区，常量代码区，全局数据区等区域的start，end。来对这些区域进行划分。

> 比如栈区，堆区是动态变化的。那么只需要增大或者减小end，即可对栈区堆区的空间大小进行控制。再比如只读代码区，在源文件编译之后，可执行程序内部已经有了虚拟地址。若此文件加载到内存中变为进程，则mm_struct中的常量代码区的start和end即可通过这些编译生成的虚拟地址来确定start和end

![image-20231116135251661](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231116135251661.png)

> 进一步理解最初的代码现象, 以及写时拷贝
>
> ![image-20231116135304253](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231116135304253.png)
>
> 最初，父进程与子进程打印出同一个变量地址相同，但是值不同。我们现在知道了，这个地址其实是虚拟地址，而非物理地址。
>
> 一个事实：父进程创建子进程时，除了一些子进程独有的属性，比如典型的pid。其余大部分属性和数据都是从父进程那里拷贝过来的。包括mm_struct 和 页表  的数据！
>
> 所以，起初，在子进程执行g_val = 200;之前，也就是修改这个全局变量之前。因为子进程的mm_struct和页表是直接从父进程那里拷贝过来的。故父子进程的g_val的虚拟地址，以及这个虚拟地址映射的物理内存中的数据都是一样的。
>
> 而当子进程执行g_val = 200;时，这是子进程对这个全局数据执行写操作。因为父子进程访问的g_val不应该互相干扰。故此时，OS在内存中的其他区域，拷贝了一个新的，子进程的g_val，赋值为200，并改变子进程的页表的映射关系（不需要改变g_val的虚拟地址）。从而当子进程改变g_val后，父子进程打印的这个全局数据的虚拟地址相同，但是映射到物理内存不同区域，值不相同。才有了最初的现象。
>
> **这种子进程写数据时进行数据拷贝的操作，称为写时拷贝！**

> 本质上，fork的返回值，由一个变量来存储，但是在父子进程内部存储的值是不同的（父进程存储子进程id，子进程存储0），其实这里也是写时拷贝！

### 为什么存在虚拟地址空间？（虚拟地址空间的好处

内存权限控制, 比如代码区只读, 不可修改

地址空间+页表可以对某些内存进行权限管理，比如常量代码区设为只读。

对于某些内存的非法访问，也可以及时禁止。从而保护物理内存。

只要使得各个进程的虚拟地址通过页表映射的物理内存是不同的，则可以保证进程之间互不干扰，即进程独立性。

#### 一、保护物理内存，增加内存访问控制

凡是非法的访问或者映射，OS都会识别到，并终止你的进程。
原因就是：比如const char* p = "abcd"; p指针保存的是虚拟地址，且这个虚拟地址所映射的物理内存不可被写。这都是基于地址空间+页表。除了这种保护只读的数据，当存在野指针或者非法访问时，地址空间+页表也能以某种方式告诉OS，从而OS可以发信号终止这个进程。这样一来，物理内存的访问都在OS的监管之下。保护了物理内存，物理内存中的数据，其他进程，以及内核的相关有效数据。

#### 二、内存管理 和 进程管理 低耦合，降低维护成本

因为有虚拟地址空间+页表，物理内存中的数据可以随意存储。只要保证虚拟地址可以通过映射找到对应的数据即可
物理内存管理 和 进程管理因此可以做到关联性很低
内存管理模块和进程管理模块 完成了解耦合。在操作系统层面，**这两个模块关联性很低，维护成本也会降低**

#### 三、实现延时分配，提高整机效率。同时提高内存利用率

我们在C语言中进行malloc时，申请内存本质是在虚拟地址空间中申请，并不会因为malloc，就立即申请内存空间。

原因是：如果我malloc时就立刻申请物理内存，且不立刻使用，则这就是一种内存资源浪费。
所以，因为有地址空间存在，上层申请内存，其实是在地址空间中申请。而当你进行对物理内存的访问时，才执行相关的内存管理算法，帮你申请内存，构建页表映射关系。然后再让你进行内存访问。 （这些是由操作系统完成的，进程0感知）

虚拟地址存在，但是物理内存中没有对应的空间。称为缺页中断。

**这样延时分配产生的好处就是：确保物理内存中的有效使用是100%的，并不会出现物理内存中申请空间但不使用的情况。提高内存的利用率。延时分配的策略，提高整机效率。**

#### 四、使内存分布有序化、实现进程独立性

第二点中：物理内存可以随意存储。但是因为页表的存在，可以建立虚拟地址和物理地址的映射关系。**从而使得从每个进程的视角看来，内存分布都是有序的。**地址空间+页表的存在，可以使得内存分布有序化！

通过让不同内存的虚拟地址映射到物理内存的不同区域, 实现进程独立性。

> 重新理解挂起
>
> 1. 创建进程时，并非一定需要将程序所有的代码和数据都加载到内存中，并创建内核数据结构，才能执行。
>
> 2. 极端情况下，当只有内核数据结构被创建出来时，就是新建状态。
>
> 3. 理论上，可以实现对程序的分批加载。同样可以实现程序的数据/代码的分批唤出。
>
> 4. 当一个进程等待某些响应时，或者短时间内不会再执行了，比如阻塞了。   此时将进程的数据和代码换出，就叫做挂起。













> 如何通过虚拟地址找到物理地址？
>
> 环境变量