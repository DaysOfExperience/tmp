# 4_Linux进程控制

## 进程创建

### fork创建子进程做了什么？

给子进程创建对应的内核数据结构, 其中大部分属性数据是从父进程那里拷贝来的. 代码和数据与父进程共享一份, 代码只读, 数据写时拷贝

> 基于进程独立性，本身，父子进程的数据必须分离。那么在子进程创建初期，直接在内存中拷贝一份父进程的数据是完全可以的。 但是这样有很大的内存浪费的风险。父进程的数据，并非所有子进程都需要使用。  即使需要使用，也不会立刻使用。  即使立刻使用，也不一定是写操作。基于高效和节省内存空间的理念，我们不能采取直接拷贝一份父进程的数据。故在子进程创建时，是和父进程共享同一份数据。对于只读的，父子进程共享数据完全可以。对于写的数据。基于进程独立性，必须进行数据分离。 操作系统采用的即 写时拷贝技术，来将父子进程数据分离。
>
> 代码共享：**通过页表来实现访问控制，使代码段是只读的，不可修改。**

**父子进程分离数据的方式：写时拷贝**

写时拷贝，在fork创建子进程这里的具体操作是：创建子进程之后，当父子进程的任何一方以写方式访问某个数据时，操作系统在内存的其他区域拷贝一份这个数据，并修改写此数据的那个进程的页表映射关系，使父子进程访问的是物理内存中的不同数据。以达到父子进程数据分离的效果，避免互相干扰。

写时拷贝好处：

提高效率(fork可以很快返回), 提高内存使用率

![image-20231116140731851](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231116140731851.png)

### fork常规用途/用法

1. 一个父进程希望复制自己，使父子进程同时执行不同的代码段。例如，父进程等待客户端请求，生成子进程来处理请求。

2. 一个进程要执行一个不同的程序。例如子进程从fork返回后，调用exec函数。（比如OJ项目中，子进程通过execl来进行g++或者运行生成的可执行程序来获取运行结果）

### fork什么时候会失败？

系统中有太多的进程

实际用户的进程数超过了限制

### vfork

创建一个子进程，共享同一个虚拟地址空间

vfork创建子进程的效率比fork要高，因为vfork所创建的子进程和父进程共用同一个虚拟地址空间。

但也因为这样，进程之间就不具备独立性，父子进程不能同时访问代码段和数据段，所以当子进程运行的时候必须要阻塞父进程，防止产生冲突。

虽然vfork效率高，但是fork因为实现了写时拷贝技术，效率提高了不少，所以vfork已经很少使用了。

## 进程终止

### 进程终止时，操作系统做了什么？

**释放进程相关内核数据结构和对应的代码和数据。 即释放进程占用的资源。**

### 进程终止的分类情况

1. 代码跑完，运行结果正确（符合预期）

2. 代码跑完，运行结果不正确（不符合预期）

3. 代码没有跑完，程序异常退出（崩溃）

### 进程退出码

进程退出码，是当进程执行结束后，用于标识运行结果的。
通常情况下，0标识success，非0标识结果不正确。非零值有无数个，用不同的非零值来标识不同的错误原因。所以，依据进程退出码，可以判断上方情况的1 和 2
当进程异常退出时（崩溃），是由操作系统发送信号给进程以实现的。此时，退出码没有意义。
进程的退出码是返回给上一级进程（父进程）的，用于上一级进程获取该进程执行结果用的。（如果上一级进程不关心，则可以忽略）
C语言中定义了一套将退出码/错误码转化为字符串描述的方案，你可以设定一套自己的用于程序中。strerror库函数可以查询C语言规定的退出码对应的退出原因。
Linux下，echo $?可查询上一个进程执行的退出码

其中C/C++程序中，main函数的return值就是该进程（程序）的退出码，我们通常写的return 0即表示当main函数运行结束时，退出码为0标识结果成功。

### 用代码如何终止一个进程

1. main函数中的return语句，即标识终止此进程。（其余函数的return仅表示此函数的结束，或者返回一个值给该函数的函数调用处）

2. void exit(int status);    C语言库函数，返回status作为退出码，并终止此进程

3. void _exit(int status);    操作系统系统接口函数，返回status作为退出码，并终止此进程

main函数中执行return n等同于执行exit(n)，因为调用main的运行时函数会将main的返回值当做exit的参数。

### exit vs \_exit

一个是C语言库函数，一个是操作系统接口函数。
区别：exit在程序退出之前，会刷新C标准库设定的缓冲区。_exit退出不刷新缓冲区

## 进程等待

### 需要进行进程等待的原因

1. 避免产生僵尸进程: 子进程退出之后，父进程不读取子进程的退出状态，不回收其资源。子进程变为僵尸进程。则子进程会造成内存泄漏。 
2.  父进程获取子进程的退出码/执行结果: 需要进程等待

**父进程通过进程等待的方式，回收子进程资源，获取子进程退出信息。**

### 父进程进程等待的方式

pid_t wait(int *status);     pid_ t waitpid(pid_t pid, int *status, int options);

wait只能阻塞式等待，waitpid可以选择等待方式，依据的是最后一个参数：0 or WNOHANG。

status是输出型参数，由操作系统填充，用于得到子进程的执行结果：正常 or 崩溃（看信号），正常的话，是否正确（看退出码）

status参数类型是int*，但是，并非以整型整体来获取子进程执行结果。而是按照比特位的方式。

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231116165525205.png" alt="image-20231116165525205" style="zoom:67%;" />

若正常终止，次低八位，表示退出码。 (status>>8) & 0xff   若崩溃，则低7位为终止信号。status & 0x7f   0x7f = 1111111
通过以上方式，即可得到status所标识的子进程退出信号 or 子进程退出码

> 进程PCB中是有对应的字段来保存进程的退出码和退出信号的，int exit_code, exit_signal;
>
> 多进程程序基本模式就是 fork  + wait/waitpid

## 进程程序替换

创建子进程必定是想让子进程做与父进程不一样的事情，如果采用判断pid的方法来进行代码分流，这样的程序会非常庞大，所以还有更好的方法，就是程序替换。

### 进程程序替换的概念+原理

用fork创建子进程后，可以用进程替换的方式，通过函数调用让子进程去执行一个全新的进程。当进程调用一种exec函数时，**物理内存中保存的该进程的数据和代码将全部被替换为新的进程的代码和数据。之后，子进程会将新的进程完整执行一遍！**
**进程替换，并没有创建新的进程，而是完全替换了一个已存在进程的代码+数据为新进程的代码+数据。所以进程的id，优先级等不会变**

> 并且，fork之后父子进程的代码共享，数据写时拷贝。那么，子进程进行进程替换时，数据和代码被替换，本质就是数据和代码被写入。<u>所以此时代码也会发生写时拷贝</u>。再将子进程的代码和数据替换为新进程的代码和数据。以此保证父子进程的独立性！！！
> exec系列函数本质上，就是把新的进程的代码和数据加载到内存中！

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231116165743743.png" alt="image-20231116165743743" style="zoom:50%;" />

### exec系列-进程替换接口函数

```c
int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ..., char * const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[], char *const envp[]);
int execve(const char *path, char *const argv[], char *const envp[]);
```

l(list) : 表示arg命令行参数采用列表形式    v(vector) : 表示arg命令行参数采用数组形式
p(path) : 有p自动搜索环境变量PATH    e(env) : 表示自己维护组装环境变量

> 第一个参数，传递要替换为的进程的路径+目标文件名，相对路径或绝对路径。 而如果函数名有p表示，第一个参数还可以传递环境变量里保存好的，比如ls，pwd。若没p，则必须传递绝对/相对路径
> 第二个参数，为命令行参数，在命令行上怎么执行这个进程，这里就怎么填。以列表形式 or 数组形式
> 第三个参数：若函数名中有e，则表示自己维护环境变量（有关这里环境变量的作用，不太理解，只能勉强用一用）exec系列函数若调用失败返回-1，若调用成功没有返回值。（也无法返回）
> execve是真正的系统调用函数（man 2），上面的六个函数都是对execve的封装，适用于不同的使用场景。（man 3）
> 本质上，第一个参数，传路径是为了让exec找到这个程序在哪里。后面args为命令行参数，意思是怎么执行这个参数。而命令行参数，比如以NULL结尾。

> 一个C程序可以fork/exec另一个程序，并传给它一些参数。这个被调用的程序执行一定的操作，然后通过exit(n)来 返回值。调用它的进程可以通过wait（&ret）来获取exit的返回值。