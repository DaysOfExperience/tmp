# 生产者消费者模型

生产者消费者模型是针对**在任务处理中既要产生数据，又要处理数据这一情景**而设计出来的一种解决方案。如果生产者生产资源很快，消费者处理资源的速度很慢，则生产者就必须等待消费者处理完数据才能继续生产，反之同理，这样的话生产者与消费者之间的**耦合度较高（依赖关系），导致总体效率较低。**
于是通过**引入一个交易场所(缓冲区)，来解决生产者与消费者之间的强耦合关系**，生产者与消费者之间不是直接通讯，而是通过这个交易场所来**间接通讯**，将两者的直接关系转变成间接关系，生产者生产完数据直接交给仓库，而消费者要使用则直接从缓冲区取出数据，**这样效率就大大的提高。**

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231117170654428.png" alt="image-20231117170654428" style="zoom:80%;" />

生产者消费者模型中有三个关键成员：生产者、消费者和缓冲区。

- **生产者（Producer）**：生产者负责生产数据，并将数据存储到缓冲区中。

- **消费者（Consumer）**：消费者负责从缓冲区中取出数据，并消费数据。

- **缓冲区（Buffer）**：缓冲区是用来存储生产者生产的数据的地方，同时也是消费者从中取出数据的地方。缓冲区可以是一个数组、队列、链表等数据结构。<u>在多线程场景中，缓冲区需要通过互斥和条件变量等互斥同步机制来实现生产者和消费者之间的协调和同步。</u>

> 便于记忆：321原则
>
> 一个交易场所：缓冲区
>
> 二个角色：生产者，消费者
>
> 三种关系：生产者和生产者：互斥关系。消费者和消费者：互斥关系。生产者和消费者：互斥，同步关系。（利用互斥锁和条件变量来实现。）

##### 生产者消费者模型的优点

- **解耦合：**
  生产者与消费者之间不直接通讯，而是借助交易场所通讯，降低了耦合度
- **支持忙闲不均：**
  可以解决某一方过忙而某一方过闲的问题
- **支持并发：**
  多线程轮询处理

# 基于阻塞队列的生产者消费者模型

**借助阻塞队列作为交易场所，互斥锁实现互斥关系，条件变量实现同步关系**

其与普通的队列区别在于，当队列为空时，从队列获取元素的操作（消费者线程进行）将会被阻塞，直到队列中被放入了元素（生产者线程进行）；当队列满时，往队列里存放元素的操作（生产者线程进行）会被阻塞，直到有元素被从队列中取出（消费者线程进行）

**因为缓冲区实际上就是一个某种数据结构组织的内存空间，只是这里用队列来充当这个缓冲区，同时加了同步和互斥机制，所以是一个阻塞队列。**

![image-20231117165017577](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231117165017577.png)

## 阻塞队列生产消费模型代码实现

[zzz](https://github.com/DaysOfExperience/Linux_System_Programming/tree/main/Thread/BlockQueueCP)

## 互斥锁&共享变量

- 因为利用条件变量进行了线程同步，因此可以让线程能够按照某种特定的顺序访问临界资源，从而**有效避免饥饿问题**。（生产者和消费者调用`pthread_cond_siganl`时是按照条件变量的等待顺序进行唤醒的）

- 条件变量的使用需要环境，在生产者消费者模型中，生产者生产完数据之后，可以signal消费者，因为生产者知道缓冲区中新增数据了。消费者消费完数据之后，可以signal生产者，因为消费者知道缓冲区中有空间了。

- 为什么`int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex)`的第二个参数是一个互斥锁：当一个线程调用此函数时，是因为它检测到了临界资源不就绪，不满足访问条件，因此它需要等待（例如消费者等待生产者生产数据），**而对于临界资源的检测本身也是一种访问，故需要在互斥的条件下进行，也就是加锁和解锁之间。**因此，当线程调用`pthread_cond_wait`时，需要传入一个互斥锁，`pthread_cond_wait`会先将互斥锁解锁，以便其它线程可以进入临界区访问临界资源。比如：消费者检测阻塞队列内没有数据，需要等待，但是它必须先把互斥锁进行解锁，生产者才能进入临界区生产数据。

- `pthread_cond_wait`第二个参数是一个锁，当成功调用wait之后，传入的锁，会被自动释放！当线程被唤醒的时候，`pthread_cond_wait`，会自动帮助线程获取锁（要竞争锁）。由此可见，条件变量本身就是和互斥锁配合起来使用的。

- `pthread_cond_wait`是一个函数，可能调用失败，也可能存在伪唤醒的情况，因此编码规范为：while (临界资源不就绪） `pthread_cond_wait(cond, mutex);`

## 为什么 pthread_cond_wait 需要互斥量（上方的第三点）

条件等待是线程间同步的一种手段，如果只有一个线程，条件不满足，一直等下去都不会满足，**所以必须要有一个线程通过某些操作，改变共享变量，使原先不满足的条件变得满足**，并且友好的通知等待在条件 变量上的线程。

条件不会无缘无故的突然变得满足了，必然会牵扯到**共享数据的变化。**所以一定要用互斥锁来保护。**没有互斥锁就无法安全的获取和修改共享数据。**

> 这里面一定是双方相互配合的

![image-20231117165306331](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231117165306331.png)

1. 注意：生产消费的过程并非只是生产者往缓冲区放数据，消费者从缓冲区拿数据。更重要和耗时的是生产者生产数据和消费者处理数据的过程。因为**缓冲区放数据和拿数据是互斥的，所以这里的执行是串行执行的**，并没有提高效率。**真正提高效率的是，提高生产者生产数据和消费者处理数据的并发度。以避免出现生产过剩或消费不及的情况，从而使系统的负载保持在一个合理的范围内。**
2. 设计多生产者多消费者的目的也是为了提高生产数据和消费数据的并发度，当然，如果生产数据和消费数据的过程很简单，则多生产多消费的意义也就不大了。若过程是大量IO的过程，则可以提高整体效率。(IO密集型)

> 前面的生产消费代码，可以把生产者输入整数和消费者消费整数稍微修改一下，体现出生产者生产数据和消费者处理数据的过程... 略略略

# 信号量（POSIX信号量）

## 信号量的理解

在Linux下，**POSIX信号量是一种线程同步机制**，用于控制多个线程之间的访问顺序。**POSIX信号量可以用于实现线程之间的互斥与同步。**

> 在之前的阻塞队列生产者消费者模型中，阻塞队列是一个共享资源，不管是生产者还是消费者，任何时刻只允许一个线程访问共享资源，所以对阻塞队列进行了加锁保护，使阻塞队列成为为临界资源。在这里，是将整个共享资源（阻塞队列）当作一个整体使用的。

**信号量使用思路与场景**：一个共享资源，不当作整体使用，将其划分为若干个小的共享资源，使得不同的执行流访问不同的小共享资源，本质上，**当不同执行流访问不同的小共享资源时，不需要进行加锁保护，可以并发执行。**而如果两个执行流访问到了同一个小的共享资源时，再进行互斥保护共享资源。

而信号量就可以用于标识可用的共享资源的数量!

---

POSIX信号量提供了两种类型的信号量

**二进制信号量**：只有两个取值：0和1，它用于表示资源是否被占用。
二进制信号量可以充当互斥锁的作用。因为信号量的初始值为1，p相当于加锁，v相当于解锁。

**计数信号量**：可以有多个取值，**它表示可用资源的数量。**
计数信号量的值通常被称为“资源计数器”，它记录了当前可用的共享资源的数量。当一个线程需要使用共享资源时，它会尝试获取计数信号量，如果当前可用资源数量大于0，则线程可以获取资源并将计数信号量的值减1。如果当前可用资源数量为0，则表示共享资源已被占用，线程需要等待直到有资源可用。

## POSIX信号量接口

```C++
int sem_init(sem_t *sem, int pshared, unsigned int value); // 初始化
int sem_destroy(sem_t *sem);    // 销毁
int sem_wait(sem_t *sem);       // 申请信号量，P操作
int sem_post(sem_t *sem);       // 释放信号量，V操作
```

因为信号量本质就是一个计数器，记录着当前的资源数目，其中初始化时的value值就表示初始时的资源数目。

在使用POSIX信号量时，线程可以通过调用`sem_wait()`函数来请求获取信号量，如果当前信号量的值大于0，则线程可以继续执行，同时信号量的值会减1；否则线程将被**阻塞**，等待信号量的值变为大于0。当线程释放资源时，可以通过调用`sem_post()`函数来释放信号量，使得其它线程可以获取资源。

# 基于环形队列的生产者消费者模型

![image-20231117202502353](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231117202502353.png)

> 可看可不看..
>
> 基于环形队列的生产者消费者模型，对比之前的基于阻塞队列的生产者消费者模型，只是缓冲区的具体数据结构变了。
>
> 如上图，环节队列是逻辑抽象结构，底层的物理结构是数组。要想达到环形队列的效果，只需在访问数组的最后一个元素的下一个元素时将下标 %= size即可。再者，环形队列有一个判空和判满的问题，因为这里的容量是有上限的，从数据结构的角度来说，一般会有一个start和end下标，当start == end时为空，而当数据为满时，不能也将start == end标定为满，因为这样空和满的判断条件就相同了。解决方法：1. 空出一个位置，当(end + 1) % size == start时，判定为满。 2. 加一个计数器，当计数器 == size时为满，计数器 == 0时为空。
>
> 但是，因为信号量的作用，在环形队列生产消费模型中，我们不需要考虑判空判满的问题。见下文。

## 结合生产者消费者

先考虑单生产者，单消费者的环形队列生产消费模型，有以下前提：

- 通过给生产者线程和消费者线程分别设定一个下标，从而标定它们当前生产和消费的下标位置。

- 我们不需要通过空出一个位置或者添加计数器的方式来避免队列为空和为满时生产消费线程的下标相同这样的判定条件重复。因为有信号量的存在。

- 因此，队列为空和为满时，生产者线程的下标一定等于消费者线程的下标。一种情况是当前缓冲区中没有数据，一种是当前缓冲区中数据已满。

目的期望：

- 当生产线程和消费线程指向了环形队列的同一个位置时（此时队列为空or为满），也就是访问了同一个共享资源，此时需要进行多线程互斥与同步。

- 当生产线程和消费线程不指向环形队列的同一个位置时，此时不需要进行互斥与同步，可以并发执行，因为没有访问同一个共享资源。

也就是：

- 当环形队列为空时，必须让生产者先执行，消费者必须等待生产者生产完至少一个数据。这也就是第一点中的互斥与同步。

- 当环形队列为满时，必须让消费者先执行，生产者必须等待消费者消费完至少一个数据。这也就是第一点中的互斥与同步。

- 当环形队列不为空不为满时，生产线程与消费线程并发执行。

## 结合信号量

信号量表征的是共享资源的数量，在环形队列生产消费模型中，设定两个信号量，分别表征数据资源数目和空间资源数目。生产者关注空间资源信号量，初始为N。消费者关注数据资源信号量，初始为0。

![image-20231117202513324](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231117202513324.png)

按照上面生产者和消费者的执行逻辑来看，每次在生产或者消费之前必须先申请信号量，**申请信号量的本质是一种对资源的预定机制。**若信号量大于0，则--信号量，继续执行。若为0，则阻塞等待信号量被其他线程释放。

这样一来，起始时，或其他时刻当环形队列为空时，`dataSem`为0，消费者没有数据资源可以申请，故必须阻塞等待。这也就是我们期望的，即当生产和消费的下标相等时，且队列为空时，必须让生产者先执行，消费者阻塞等待。

当环形队列为满时，`spaceSem`为0，`dataSem`为N，生产者没有空间资源可以申请，故必须阻塞等待。这也就是我们期望的，当生产和消费下标相等时，且队列为满时，必须让消费者先执行，生产线程必须阻塞等待。

（注意，上方两种互斥情况下，只有当另一方生产/消费完，执行完V操作之后，阻塞方才能P成功，这也就实现了互斥和同步

当环形队列不为空时，生产和消费的下标不同，此时并没有访问同一个资源，故**可以并发执行。**

## 结合多生产多消费

多生产多消费时，任何一个生产者和一个消费者之间都已经通过信号量达到了应有的互斥与同步，现在需要考虑的是生产生产之间和消费消费之间的互斥关系。

生产生产之间，消费消费之间，需要保护的共享资源为下标：c_index\_或者p_index\_，环形队列：ring_queue_（STL：vector，不是线程安全的），故，需要在push和pop内部，进行加锁，构建临界区，保护临界资源。

因为这里生产和消费之间的互斥，已经在当下标相等时，为空或为满时，由信号量维护了，**所以这里用两把锁，分别维护生产生产之间和消费消费之间。**（见代码实现）

## 环形队列生产消费模型代码实现

[RingQueueCP]([Linux_System_Programming/Thread/RingQueueCP at main · DaysOfExperience/Linux_System_Programming (github.com)](https://github.com/DaysOfExperience/Linux_System_Programming/tree/main/Thread/RingQueueCP))

## 为什么效率高，优势（基于环形队列的生产消费模型）

我们可以看到，多个生产之间，在对环形队列push时，内部是互斥的，也就是串型执行的。多个消费之间，在对环形队列pop时，内部是互斥的，也是串行执行的。**对比阻塞队列的生产消费模型来说，改进就是，当缓冲区，环形队列不为空且不为满时，生产和消费的push和pop可以并发执行。**

还是那句话，生产消费的过程并非只是`pushpop`的过程（放数据和拿数据的过程），还有**生产者放数据之前生产数据和消费者拿数据之后处理数据的过程（这里才是最耗时间的）。多生产多消费的意义是，可以让生产数据和处理数据时多个线程并发执行，从而提高效率。 （和基于阻塞队列的一样）**

## 信号量的理解

信号量的本质就是一个计数器，表示当前资源数目。计数器的意义是什么呢？

在之前使用互斥锁，条件变量的使用场景下，常规流程是：申请锁->判断临界资源是否就绪->就绪则访问，不就绪则释放锁并在条件变量下等待->资源就绪获取锁访问临界资源->释放锁。

**而信号量这个计数器的意义就是：可以不进入临界区就得知资源情况，减少了临界区内的资源是否就绪的判断。**信号量就是一种资源预定机制，当P操作成功时，就代表着此时有一个资源可以供你获取/访问（比如环形队列中的空间资源/数据资源）。
