# 6_进程间通信

## 进程间通信的作用，应用场景，必要性

进程间通信，是建立在多进程之上的。如果是单进程，则无法利用并发能力，更加无法进行多进程协同。**多进程要想实现多进程协同（目的），就必须进行进程间通信（手段）。**

具体的进程间通信的目的（示例）：比如：**1. 数据传输**：一个进程需要将它的数据发送给另一个进程。**2. 资源共享**：多个进程之间共享同样的资源。 **3. 通知事件**：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。**4. 进程控制**：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。

多进程通过进程间通信，比如具体的上方几个目的，实现多进程协同。

**数据传输: 管道、消息队列
数据共享: 共享内存
进程控制: 信号量**

## 进程间通信的技术背景

进程是具有独立性的

进程 = 进程的内核数据结构 + 进程对应的代码和数据。不管是两个独立的进程，还是父进程fork创建子进程，进程的内核数据结构还有代码和数据都是有独立性的。因为虚拟地址空间+页表的存在，进程的虚拟地址通过页表映射到物理内存的不同区域，即使是父进程fork创建子进程，子进程的内核数据结构也会有独立的一份，而代码和数据在创建之初和父进程共享，但是因为写时拷贝技术的存在，子进程的代码和数据仍然是具有独立性的（比如，非常量全局数据，在父子进程之一写时，会拷贝一份。而代码，比如调用execl函数进行进程切换时，也会发生代码的写时拷贝）

**因此，基于进程独立性，进程间如果想进行通信，成本是比较高的。**

## 进程间通信的本质理解

因为进程是具有独立性的

所以，**要想实现进程间通信，首先要让不同进程看到同一份资源（同一块"内存"，这个内存是特定的结构组织的），这个内存资源，不能隶属于任何一个进程，而更应该强调"共享"（其实就是属于操作系统管理的）**

# 管道

## 管道IPC：匿名管道

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231116141737046.png" alt="image-20231116141737046" style="zoom:67%;" />

### 匿名管道的本质原理

在父进程fork创建子进程时，子进程会有自己独立的内核数据结构（如页表，虚拟地址空间，PCB，文件描述符表等）, 子进程的大部分内核数据结构的数据都是从父进程那里直接拷贝过来的，当然，部分字段还是需要修改的（如pid等），**而其中的文件描述符表的数据是从父进程拷贝过来的, 因此与父进程完全一致。**

<u>因此，当父进程以读和写方式打开某一个文件之后，进行fork，子进程继承了父进程的文件描述符表，子进程也以读和写方式打开了这个文件。</u>因为管道是单向通信的，故父子进程关闭自己不需要的一端之后，就可以通过该匿名管道文件进行通信。

demo示例代码：

### pipe 系统调用

创建匿名管道时，是有专门的系统调用的，因为管道文件和普通文件在性质上是有差别的。

int pipe(int pipefd[2])

该系统调用用于创建一个**纯内存级的匿名管道文件**，参数为输出型参数，pipefd[0]保存读端文件描述符，pipefd[1]保存写端文件描述符（整型，文件描述符表的下标）。

## 管道IPC：命名管道

上方讲的匿名管道适用于有亲缘关系的两个进程之间进行IPC。其实利用的就是文件描述符表继承机制，从而让双方进程看到同一份资源（文件）。

**而对于没有亲缘关系的两个进程来说，无法利用文件描述符表的继承机制，但是可以直接打开磁盘中的同一个文件，这样在OS内核中就只有一个struct file结构体，也实现了让两个进程看到同一份资源。**

### mkfifo

mkfifo是Linux下的一个命令，可用于创建命名管道文件

`$ mkfifo filename`

同时，mkfifo也是一个C标准库函数   ` int mkfifo(const char *filename,mode_t mode);`

第一个参数为命名管道的绝对/相对路径，第二个参数为管道文件的权限设置。

### 命名管道的本质理解

mkfifo C标准库函数，可用于创建一个命名管道（文件），**此文件在磁盘中有对应文件实体**，也就有了路径，而路径是具有唯一性的。

**让两个进程打开磁盘中的同一命名管道文件，则路径的唯一性使得这两个进程使用open打开此fifo之后，文件描述符表中的struct file*指向的是OS内核中的同一个struct file（对应那个命名管道文件），这样就让两个进程看到同一份资源了。**

注意：

**此命名管道文件在内核缓冲区中的数据，依旧不会刷新到磁盘中，磁盘中那个命名管道文件，仅仅是一个文件名+属性，没有内容。**

**进程间利用命名管道文件进行IPC仍然是纯内存级的，因为不会进行落盘/持久化数据。**

命名管道示例代码: ...

## 管道读写的4种情况

1. 写慢，读快，则将管道里数据读完就会read阻塞等待，需要等待写端写入数据
2. 读慢，写快，管道写满就不能再写了，需要等待读端读取数据
3. 写端关闭，read不会阻塞，read读到管道结尾，返回0
4. 读关，写仍然在写，则OS会终止写端进程

（这里可以用demo代码进行测试验证）

## 管道的特点

1. 匿名管道适用于具有亲缘关系的进程之间进行进程间通信 - 常用于父子进程。因为利用的就是子进程继承父进程的文件描述符表的这个机制, 而命名管道文件可用于无关联的两个进程之间进行IPC

2. **内核中匿名管道文件是一种纯内存级文件，在磁盘中没有对应的文件实体，不会把内核缓冲区中的数据进行落盘和持久化。**所有的进程间通信都是**内存级通信**

3. **命名管道文件在内核缓冲区中的数据，依旧不会刷新到磁盘中，磁盘中那个命名管道文件，仅仅是一个文件名+属性，没有内容。** 因此也是纯内存级通信

4. **管道提供了访问控制，内核会对管道操作进行同步与互斥** (参见读写的四种情况)

5. **管道提供流式的通信服务 - 面向字节流**

6. **管道的本质就是文件, 因此管道的生命周期随进程, 打开管道的所有进程退出后管道就会被释放。**

7. **管道是单向通信的，半双工的（一方读，一方写）**，数据只能向一个方向传输。如果需要进程双向通信，则需创建两个管道。

# System V 共享内存 IPC

![image-20231116215638482](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20231116215638482.png)
进程间通信的前提是让不同进程看到同一份资源。

**共享内存即在物理内存上开辟一块空间，然后多个进程通过页表将这同一个物理内存映射到自己的虚拟地址空间中(共享区)，通过自己的虚拟地址空间来访问这块物理内存，达到数据共享的目的。**

这段物理内存会被映射进虚拟地址空间中**栈区与堆区之间的共享区**（回顾，动态库的加载链接也是会被加载到共享区。）

也正是因为这种特性，使得**共享内存成为了最快的进程间通信的方式**，因为它直接通过虚拟地址来访问物理内存，比前面的管道少了内核态和用户态的几次数据拷贝和交互。(管道的本质是文件, struct file属于内核数据, 在内核空间中)

**共享内存的生命周期随操作系统，而不是随进程**

## 共享内存本质理解（OS管理的角度）

对于共享内存的理解不能只理解为一段物理内存中的内存空间。共享内存的提供/管理者是操作系统，OS内可能会有很多共享内存，则**OS必须要管理这些共享内存**，管理的本质就是：先描述，再组织。所以，**OS必须要对这些共享内存建立对应的内核数据结构，去描述这些SHM。**

故，**共享内存 = 共享内存块 + 共享内存对应的内核数据结构**

所以，如果进程申请4096字节的共享内存空间，则OS为了这段共享内存所占用的内存空间一定大于4096字节（因为还有内核数据结构）（其实管道也是需要管理的，只是管道的本质就是文件，所以**管道管理 = 文件管理**。**而这里的共享内存是OS为了进程间通信单独设立的一个模块。**）

共享内存IPC示例代码 ...

## 共享内存的使用流程, 相关系统调用

1. **创建共享内存**

2. **将共享内存映射到虚拟地址空间**
3. **进行操作**
4. **解除映射关系**
5. **释放共享内存**

`key_t ftok(const char *pathname, int proj_id);`

> 用于创建key值，第一个为随意一个文件路径，第二个为随意一个整数，创建的key值用于在内核层面标识每一个共享内存，创建共享内存shmget需要用到。
>
> ftok函数内部就是算法，用于生成一个唯一的关键值。（类似哈希函数的道理），值无所谓，重点是要唯一。

**创建共享内存:**

`int shmget(key_t key, size_t size, int shmflg);`

用于创建/获取共享内存，即在物理内存中申请一段共享内存空间。

> 参数1 : ftok创建的key值，参数2 : 共享内存段空间大小（最好是页的整数倍（4kb，4096字节），避免资源浪费，因为你申请4097，则OS创建的SHM段大小也为8kb），参数3 : 为宏的组成，IPC_CREAT IPC_EXCL 共享内存权限设置的组合。
>
> IPC_CREAT | IPC_EXCL：若key对应的SHM不存在，则创建，并返回SHM的用户层shmid，若已经存在，则出错返回（SHM的创建者可以使用这个，因为这样可以保证SHM一定是全新的）
>
> IPC_CREAT：若key对应的SHM已经存在，则返回，不存在，则创建并返回。
> 注意SHM创建进程要加SHM的权限设置。

**建立共享内存和进程虚拟地址空间的映射关系**

`void *shmat(int shmid, const void *shmaddr, int shmflg);`

建立共享内存和进程虚拟地址空间的映射关系，关联/attach起来。

> shmid即shmget返回的SHM在用户层的标识符（类似文件描述符），后面两个设置为nullptr和0即可... 略了..  返回值即共享内存attach之后对应的虚拟地址。

**解除共享内存和进程虚拟地址空间的映射关系**

`int shmdt(const void *shmaddr);`

> 解除共享内存和进程虚拟地址空间的映射关系，进行detach。参数为shmat的返回值，即共享内存的虚拟地址。

**删除共享内存**

`int shmctl(int shmid, int cmd, struct shmid_ds *buf);`

用代码，系统调用删除共享内存。

`shmctl(shmid, IPC_RMID, nullptr)`即可

---

> shmget的第一个参数 key值 和 返回值shmid的关系
>
> key值，是当进程间想通过共享内存进行IPC时，用key值在OS内核层面标识每个共享内存的唯一性。 这样，两个进程通过同一个key值，就可以获取到同一个共享内存，这里shmget的返回值是用户层共享内存的一个id值，类似open的返回值文件描述符。
>
> 后面进行shmat shmctl都是使用shmid，而key，仅仅是在shmget，创建/获取该共享内存时，帮助进程间获取到同一个共享内存。
>
> key是在内核层面标识共享内存。shmid是在用户层标识共享内存。

> Linux关于共享内存的命令
>
> `ipcs -m`  查看当前OS中所有的共享内存
>
>  key shmid owner perms(权限) bytes(共享内存大小) nattach(该SHM挂接的进程数量) 
>
> `ipcsrm -m shmid`
>
> 使用命令删除一个共享内存。

## 从虚拟地址空间角度理解共享内存和管道的区别

共享内存机制：在物理内存中申请一段内存空间，通过用户空间页表（页表分为用户空间页表和内核空间页表）建立起物理内存和进程的虚拟地址空间之间的映射关系，**具体映射到虚拟地址空间中的堆栈间的共享区。
这样，进程就可以使用shmat返回的虚拟地址通过用户空间页表映射直接访问这段物理内存，这是不需要OS内核的**

而虚拟地址空间分为0~3G的用户空间和3~4G的内核空间，上方的共享区就是在用户空间中。进程可以直接访问用户空间，但是不能直接访问内核空间，访问内核空间需要通过系统调用。

管道机制：管道机制的本质是文件机制，进程间通过访问内核中的同一个文件，从而看到同一份资源进行IPC，而不管是匿名管道还是命名管道，本质都是内核中的struct file以及文件的内核缓冲区。**这部分数据本身是存储在物理内存中的，通过内核空间页表映射到虚拟地址空间的内核空间中，这就是为什么进程间通过管道通信需要使用write，read这样的系统调用，因为内核空间的访问必须通过系统调用。**（这里也是虚拟地址空间机制对于物理内存的保护的体现）

## 共享内存的特点

1. **共享内存是最快的进程间通信方式**，一旦这样的内存映射到共享它的进程的地址空间，**这些进程间数据传递不再涉及到内核**，换句话说是进程不再通过执行进入内核的系统调用（如read，write）来传递彼此的数据

2. **共享内存缺乏访问控制，共享内存没有进行同步与互斥**

> 上方示例代码中，server端运行起来后，不管client端有没有执行，不管这个共享内存的attach进程数是几个，有没有人写入，server端都是一直读取，这是缺乏访问控制的表现。（上方代码中，利用管道，增加了访问控制）

3. **共享内存的生命周期随操作系统，不同于管道的生命周期随进程**

> 如果不进行shmctl 和 命令行上的ipcsrm -m，则进程结束后，共享内存一直存在。
>
> 共享内存的生命周期随OS，而不是随进程，若某进程创建共享内存，attach，detach，而没有删除，则进程结束，该共享内存也不会自动销毁。
