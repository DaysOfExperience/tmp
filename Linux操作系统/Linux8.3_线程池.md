# 线程池

一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而**线程池维护着多个线程**，等待着监督管理者分配可并发执行的任务。**这避免了在处理短时间任务时创建与销毁线程的代价。**线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。 

# 线程池的应用场景

1. 需要大量的线程来完成任务，且**完成任务的时间比较短。** 
   WEB服务器完成网页请求这样的任务，使用线程池技术是非常合适的。因为**单个任务小，而任务数量巨大**，你可以想象一个热门网站的点击次数。 但对于长时间的任务，比如一个Telnet连接请求，线程池的优点就不明显了。因为Telnet会话时间比线程的创建时间大多了。 
2. **对性能要求苛刻的应用**
   比如要求服务器迅速响应客户请求。
3. **接受突发性的大量请求，但不至于使服务器因此产生大量线程的应用。**
   突发性大量客户请求，在没有线程池情况下，将产生大量线程，虽然理论上大部分操作系统线程数目最大值不是问题。但短时间内产生大量线程可能使内存到达极限， 出现错误

# 线程池示例

1. 创建固定数量线程的线程池，循环从任务队列中获取任务对象。
2. 获取到任务对象后，执行任务对象中的任务接口

# C++实现简单的线程池

[tiny线程池](https://github.com/DaysOfExperience/Linux_System_Programming/tree/main/Thread/ThreadPool线程池)

> log.hpp就是一个打印日志的功能。mutex.hpp实现了一个RAII式的加锁解锁类，参数是一个锁指针。
>
> task.hpp就是对线程池内线程执行的任务的一个简单模拟。main函数生产task，调用线程池的pushTask方法，将task放入线程池的任务队列中，线程池内等待任务的线程被signal然后执行任务。
>
> thread.hpp对于线程的封装，线程的数据成员有线程名，执行例程方法，参数，tid。就是一个很简单的封装。并不是构造时直接pthread_create，而是需要调用一个create方法。线程池构造时构造若干个thread对象。线程池的run方法中调用线程的create方法，使线程执行routine等待任务队列中的任务。

线程池的基本原理就是生产消费模型，main函数充当生产者，放入线程池的任务队列缓冲区中，然后利用条件变量唤醒pthread_cond_wait的线程，线程执行任务。这里需要加锁保护临界资源，在生产消费之间，消费消费之间都需要加锁实现互斥(因为此处仅main在生产，故没有生产生产之间的关系，但是也实现了互斥)，还需要条件变量实现同步机制。

对于routine函数，因为类的普通成员方法有一个隐藏的this指针参数，因此不能直接作为线程的执行例程方法（void\*(\*p)(void*)），因此需要将其定为static，但是static方法不能访问非static数据成员。也就导致了不能直接访问task_queue_，mutex，cond等数据成员，如果想直接访问，需要加static。但是如果这样的话，所有线程池都共用一个任务列表，锁，条件变量是不合适的。

解决方法是：将routine设为static方法，然后线程传参时传一个线程池对象的this指针过去，static成员方法不能访问非static数据成员的原因就是因为没有this指针。现在传一个过去，这个routine就可以访问任何非static数据成员和非static方法了。

有关加锁，和条件变量的使用，就是常规的生产消费模型中锁和条件变量的使用。

# 单例模式

## 单例模式是什么

单例模式是一种 "经典的, 常用的, 常考的" 设计模式.

## 单例模式的特点

**某些类, 只应该具有一个对象(实例), 就称之为单例**.例如一个男人只能有一个媳妇. 

在很多服务器开发场景中, 经常需要让服务器加载很多的数据 (上百G) 到内存中. 此时往往要用一个单例的类来管理这些数据.

## 饿汉模式与懒汉模式

分为懒汉模式和饿汉模式。懒汉方式最核心的思想是 "延时加载". 从而能够优化服务器的启动速度.

### 饿汉方式实现单例模式

```C++
template <typename T>
class Singleton {
private:
	static T data;
public:
	static T* GetInstance() {
		return &data;
	}
};
```

只要通过 Singleton 这个包装类来使用 T 对象, 则一个进程中只有一个T对象的实例。

### 懒汉方式实现单例模式

```C++
template <typename T>
class Singleton {
	static T* inst;
public:
	static T* GetInstance() {
		if (inst == NULL) {
			inst = new T();   // 此时再进行构造此单例对象
		}
		return inst;
	}
};
```

存在一个严重的问题, 线程不安全. 第一次调用 GetInstance 的时候, 如果两个线程同时调用, 可能会创建出两份 T 对象的实例. 但是后续再次调用, 就没有问题了.

### 懒汉方式实现单例模式(线程安全版本)

```C++
// 懒汉模式, 线程安全
template <typename T>
class Singleton {
	volatile static T* inst; // 需要设置 volatile 关键字, 否则可能被编译器优化.
	static std::mutex lock;
public:
	static T* GetInstance() {
        if (inst == NULL) { // 双重判定空指针, 降低锁冲突的概率, 提高性能.
            lock.lock(); // 使用互斥锁, 保证多线程情况下也只调用一次 new.
            if (inst == NULL) {
            	inst = new T();
            }
            lock.unlock();
        }
        return inst;
	}
};

```

注意事项: 

1. 加锁解锁的位置 
2. 双重 if 判定, 避免不必要的锁竞争
3. volatile关键字防止过度优化

## 线程池的单例模式

> 将构造设为private，拷贝和赋值设为delete。对外提供一个static方法，内部有一个static对象指针（设为单例模式的类的对象指针）。static方法用于获取这个static对象指针。也就是static ThreadPool<T>* threadpool_ptr。在static接口getThreadPool中，实现懒汉模式逻辑。
>
> getThreadPool有一个线程安全问题，也就是多线程同时调用此方法时，可能出现内存中创建出多份单例对象的情况。后面再调用时，因为threadpool_ptr指针不为nullptr，就不会出现这种情况了。
>
> 为了避免上述情况发生，需要加锁保护。
>
> 加锁保护之后，可以有一个优化。也就是再套一层判断。因为只有第一批同时进入这个函数的线程可能有安全问题，后面当对象创建出来之后，单例指针不为nullptr，再进入方法中不再需要加锁解锁这样的过程。因此又加了一层判断，减少后期无意义的竞争锁，提高效率。

# STL,智能指针和线程安全

## STL中的容器是否是线程安全的?

**不是**. 原因是, STL的设计初衷是将性能挖掘到极致, 而一旦涉及到加锁保证线程安全, 会对性能造成巨大的影响. 而且对于不同的容器, 加锁方式的不同, 性能可能也不同(例如hash表的锁表和锁桶). 因此 STL 默认不是线程安全. **如果需要在多线程环境下使用, 往往需要调用者自行保证线程安全.** 

## 智能指针是否是线程安全的?

对于 unique_ptr, 由于只是在当前代码块范围内生效, 因此不涉及线程安全问题. 

对于 shared_ptr, 多个对象需要共用一个引用计数变量, 所以会存在线程安全问题. 但是标准库实现的时候考虑到了这个问题, 基于原子操作(CAS)的方式保证shared_ptr能够高效, 原子的操作引用计数.
