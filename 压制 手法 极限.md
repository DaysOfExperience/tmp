## 导论篇

**1**   概述..  真概述....

2   概述, 依旧概述= =

## 前置篇

企业抽奖大揭秘  逻辑: 所有人中抽一个中某一个奖并将该人剔除, 然后再抽一个人中第二个奖 逻辑很简单(每个人只能中一个奖)
每次抽奖者发起请求会随机生成一个随机数作为索引, 根据这个随机数索引去抽奖者列表中取出这个索引的用户, 即为中奖者(一个盒子里若干小球, 取出一个为一次抽奖)

微信摇一摇大揭秘  抽奖是用户自行发起, 因为无法提前确认参与抽奖者的人数, 所以就无法像企业抽奖一样构建这个抽奖者列表，那么就只能换一种方式，将随机数应用到奖品上，而不是在抽奖者身上(这里和项目中的抽奖方式是一样的)

支付宝集福卡大揭秘   逻辑类似, 抽奖用户数量不定, 且抽奖次数不定, 我们只对针对奖品进行概率处理, 依旧是一个区间, 每个奖品占用不同大小的区间, 每次抽奖分配一个随机数, 随机数在哪个区间就中哪个奖(每个人每次抽奖, 各个奖品中奖概率都不同, 可以灵活调整..)   

微信抢红包大揭秘   100元发10个包, 20个人先到先得(这里很简单, 企业抽奖逻辑实现即可10个红包, 长度10的数组, 每次抢红包, 生成0-9随机数, 抢到后删除这个红包, 数组长度减1), 重点在于, 如何实现金额随机且合理, 并且10个包恰好分完100元?

## 设计篇

#### 需求整理与分析

前面分析了一些常见的概率活动的核心设计与代码实践，总体来说概率性的活动最终的处理和实现都是通过随机数来完成的，只是这个随机数的用法根据业务场景的不同而不同.

线上活动抽奖系统: 

- 奖品信息后台管理   奖品管理 优惠券(特殊奖品, 非实物, 单独处理)管理  黑名单管理(用户黑名单以及ip黑名单)
- 抽奖逻辑的实现   准入校验:判断该用户是否有资格抽奖(各种角度的检测)  中奖匹配(核心..)  奖品发放(其实就是, 中奖后的逻辑, 比如库存扣减, 统计获奖情况, 黑名单处理..等等)
- 非功能需求  高并发高性能 可靠性 幂等性..(?)    防止超发   持续性的非秒杀的线上抽奖活动, 中奖概率需合理设置, 防止奖品在一开始就抽完

#### 业务流程梳理

奖品后台管理admin和抽奖逻辑lottery    前者较简单就是增删改查  这里只谈论后者

后者在上方需求整理与分析中已经说过, 就是三个模块: 准入校验 -> 中奖匹配 -> 奖品发放   实际也是这样的顺序

准入逻辑   抽奖用户资格校验 即: 用户黑名单，ip黑名单，以及用户抽奖次数，ip抽奖次数的限制

奖品匹配    核心还是随机数的区间匹配

奖品发放    库存扣减(若库存不足则可以返回未中奖) -> 生成中奖记录 -> 中大奖的记入黑名单

整体流程    ??????????(计算机网络?)   👀

#### 系统架构设计

服务拆分 网关微服务 用户微服务 抽奖微服务    👀

整体架构  访问层 接口层 服务层(用户服务, 抽奖服务) 存储层(mysql redis)

#### 数据库设计

MySQL

用户表  **id自增主键**  用户名 密码 性别 年龄 邮箱  地址 手机号 卡号 **创建时间 修改时间**

奖品表  id自增主键 奖品名称 数量 剩余数量 中奖概率区间 发奖周期 奖品图片链接 位置序号 奖品类型 扩展数据 奖品有效周期开始时间  奖品有效周期结束时间  发奖计划 开始 结束 状态 创建时间 修改时间 操作人IP

优惠券表  **id自增主键  奖品id(关联奖品表)** **优惠券编码** 创建时间 更新时间 状态

用户每日抽奖次数表  id自增主键 用户id 日期 抽奖次数 创建时间 修改时间

中奖记录表  自增主键 奖品id(关联奖品表) 奖品名称 奖品类型 用户id 用户名 <u>抽奖编号</u> 获奖信息 创建时间  用户ip 状态

用户黑名单表

ip黑名单表

## 核心篇

MySQL版本抽奖核心功能实现

#### 基于MySQL实现基本版抽奖系统v1

准入校验 -> 奖品匹配 -> 奖品发放   直接与DB交互

![image-20250329165613643](C:\Users\yangzilong\Desktop\markdown\CS\image-20250329165613643.png)

基于MySQL的基本版抽奖系统的优缺点

- 简单 引入的组件少 维护也简单

- 性能一般因为直接与DB交互进行持久化(后面使用Redis缓存进行优化)   奖品概率的设置有缺陷(使用奖品池进行优化)

#### 用户鉴权详细设计

👀

#### 准入校验详细设计

用户黑名单校验 IP黑名单校验  用户抽奖次数校验  IP抽奖次数校验(两个hash, 找key的时候要%一下ip哈希表的长度(初始为2))

#### 奖品匹配详细设计

奖品的匹配是抽奖系统的核心，既要体现出随机性又要体现出公平性，保证每个用户的中奖概率相同，又要让每种奖品的中奖率不同，奖品级别越高，中奖概率越低。

中奖概率设置: 10000是总区间, x等奖为总区间的一个子区间, 子区间大小代表中奖概率大小. 每次抽奖生成一个随机数, 用随机数在区间的落点判断中奖情况

奖品匹配逻辑: 随机数匹配呗. 而奖品信息以及奖品概率信息的设置是奖品管理后台admin完成的

#### 奖品发放详细设计

1. 库存扣减, 即奖品剩余数量减一(注意防止超发)
2. 如果奖品类型是优惠券的话，还需要单独发放优惠券  (有编码)
   第一步: 查询一张可用优惠券(状态为1) 第二步: 可用优惠券数量减一(设置状态为2)  要保证这两步的原子性, 要加分布式锁
3. 生成中奖记录
4. 大奖限制处理  (IP和用户都要加入黑名单...)

## 优化篇

#### 基于Redis缓存优化抽奖系统v2

对于一些可缓存的信息, 采用Redis进行优化, 提升访问速度

##### 奖品信息缓存

数据量不大, 完全可以全量缓存到Redis, 另外中奖概率不会很高, 故奖品信息更新频率不会很高

string   全量奖品信息json序列化后缓存到Redis中

旁路缓存 - 读的时候优先读缓存, 若缓存没有则读数据库并更新到缓存  写的时候写数据库并删除缓存
为什么旁路? 读远大于写(抽奖就会读, 而只有中奖才写)



只删除一次可能会出现数据不一致吧?2.这里因为写少，所以可以允许少量的不一致吗? 3.是否通过设置过期时间来保证数据不一致的持续时间比较短呢?过期时间应该设置多少呢?4.如果是写多的场景，是不是一般都采用延时双删的策略呢?如果需要更精确的话，是不是就得通过监听 mysql 的 bin log 来更新缓存?
是的，旁路缓存是没办法做到完全一致性的

##### 用户黑名单缓存

目的/作用: 减少用户抽奖的准入校验耗时

为什么hash?  避免序列化的成本?     用户之间是一个一个hash  独立互不影响, 更新时只更新单个字段, 效率更高

hash     black_user_info_xxx  field value 为用户的各种信息

旁路缓存  :  对于缓存失效不是很敏感 + 写的情况较少

##### IP黑名单缓存

目的/作用: 减少用户抽奖的准入校验耗时   hash  black_ip_info_xxx   旁路缓存

##### IP抽奖次数缓存

hash    key : ip%constant.IpFrameSize(Ip哈希表的长度初始为2(防止大key))   field:ip  value:抽奖次数

也就是两个key两个hash表, 

旁路缓存

另外, ip抽奖次数的统计有时间限制  统计优化方案: 设置一个定时任务ResetIPLotteryNums()每日0点清除缓存中所有ip的抽奖次数

##### 用户抽奖次数缓存

hash  key:user_id%constant.UserFrameSize(User散列长度)    user_id  : 抽奖次数    旁路缓存

缓存使用场景

1. 准入校验时, 这里认为缓存的用户抽奖次数不可靠.. 若缓存通过校验, 还要再查一次DB   性能提升的地方在于, 对于已经超出次数的用户, 查询缓存即可, 不用查db
   也就是, 没超过会多一个缓存的查验消耗. 超过了就将DB查验转换为缓存查验

   > 一般不会吧，缓存的更新是基于 db 的，一般情况下是缓存漏写，或者是些缓存失败
2. 和IP抽奖次数校验一样, 也是每日0点清空

> 抽奖次数不是变更频繁吗，那不是会很快失效
> 不是所有用户的抽奖总次数，而是具体用户的抽奖次数，变更不会太大的，，一个用户抽奖次数也是有限制的
>
> ?????????????

##### 优惠券缓存

虚拟类, 数量较多, 抽到优惠券后, 先从Redis扣除, 若成功扣除, 再从DB扣除. 而如果缓存中显示没有剩余余量, 则直接返回, 不用再查数据库

> 有没有可能缓存中显示没有, 但是数据库还有呢? ok后面说了
>
> 那有没有可能缓存显示有, 数据库已经没有了呢  也就是, 数据库扣了, 而缓存没扣, 这个是不可能的, 因为扣除时一定是缓存先扣

set   key prize_coupon_prize_id 为什么Set? 优惠券具有唯一性不允许重复, 和Set的属性很匹配; 且发放时任意一张都可以, 本质没有区别, 所以直接rpop或者lpop即可

缓存模式不是旁路.    因为若缓存中显示没有优惠券, 此时不会再查DB, 而是直接返回, 所以这里不能使用旁路的查缓存没有则查DB并同步缓存的模式.     所以在奖品上传完, 在抽奖活动还没开始之前, 就需要将优惠券的信息导入到缓存中.  而后台数据管理在更新优惠券信息后, 也需要导入同步到缓存中

可能存在少发问题.. 可以解决  (少发是指, 缓存扣除成功, 而数据库没扣, 返回的其实就是, 这次未中奖, 这种情况的少发没问题, 适时将数据库同步给缓存即可) 



对于有余量的情况, 如果不做缓存，每次都是直接在 db 中扣减，如果做了缓存，每次不仅要在 db 中扣减，还需要在缓存中扣减，对于扣减成功这种情况，因为多了一个在缓存中的操作，所以加缓存应该是降低了性能吧，我们假定降低点性能为 decline。
对于没有余量的这种情况，不加缓存的情况下，需要到 db 中操作才可以返回结果，加了缓存的情况下，直接在缓存中操作即可返回结果，假设对于扣减失败的情况，加了缓存相比不加缓存，性能提升为 improve。
我的问题是:我们怎么知道对优惠券加缓存是decline 大还是 improve 大?
如果【大部分情况下扣减都是成功的】这个结论是正确的，那么decline 将会大于 improve(直觉上)，也就是加了缓存之后，会降低整体的性能，并没有起到提升性能的作用。

所以其实大部分情况下是没有余量的哈哈哈哈

奖品抽完的所有情况都是未中奖啊，这样就不用走db 了

我说实话  还真是





#### 基于奖品池优化抽奖系统V3

优化点: 前面分析过，抽奖系统除了要求高性能以外，还要在发奖功能上具有合理性。由于是线上的活动抽奖，奖品在整个活动周期内的中奖概率应该是均匀分布的，不应该在活动一开始，就被大量抢光。所以需要将奖品的中奖概率需要均匀设置，在实现上主要依赖于**奖品池和每种奖品的发奖计划**来实现

优化点: 若缓存中数量就是全量, 则虽然概率设定的没问题, 但是依旧可能在活动开始的热度较高时将奖品抽完, 则造成活动中后期无奖可发的问题. 我们希望的是活动期间均匀发奖

所以奖品池的数量应是总量的一部分, 且动态变化的，会有一定的填充机制，会每隔一段时间往奖品池中填充奖品，这样在同一时刻只有部份奖品可以被抽取，保证在活动周期内，任意时刻都可能抽中奖品

**奖品池结构和使用逻辑**

所有奖品的数量的Redis缓存 - hash

和之前优惠券缓存一样, 扣减时先扣减缓存中的奖品池, 再扣减db. 若缓存中显示数量不足, 则直接拒绝(优化了性能)

**奖品池更新**

- 发奖计划

奖品池的填充，会每隔一段时间进行，填充多少数量**根据每种奖品的发奖计划确定**，(奖品表tprize中有一个prize plan字段，这个字段就是发奖计划)

> 明确发奖计划的字段是什么含义..  

- 发奖计划更新  (为什么要更新: 就是因为比如一个发奖计划执行结束, 有的奖没发出去啊, 很简单)

发奖周期, 发奖开始时间, 发奖结束时间    根据这三个字段去更新发奖计划... 

还是上面例子，假设一共有20件奖品，prize_time为5，需要在5天内发完，那么在更新这个奖品发奖计划的时候，从当前时间开始往后推5天，把这20件奖品分摊到后面这五天的某些时间点上，如上面所示，更新完之后，还要将prize begin更新为当前时间，prize end 更新为 prize beqin + prize time

1. 手动更新(admin端出发)
   比如新增了奖品, 更新了奖品数量, 则这个发奖计划就需要调整, 依旧是根据周期, 开始, 结束, 数量来进行调整...  (重新按照发奖周期往后推一段时间，设置一下奖品需要发出的时间点。)
2. 自动更新
   只需要更新当前时间大于prize_end时间的奖品(道理很简单, 也就是之前的发奖计划执行完了, 但是却没发完, 重新分配) 5min一次
   举例

> 那也就意味着, 这里的发奖计划有可能无法严格执行完, 那如果一个计划执行完, 再调整, 再执行, 再调整, 一共执行了三次, 比如一开始的发奖周期是4天, 也就是一共执行了12天, 这样不会不太好吗?

- 奖品池填充  (如何根据发奖计划去更新奖品池:)

  每分钟一次即可, 因为之前是秒级别的  
  根据当前时间和奖品发奖计划对应的时间来确定，会把奖品的发奖计划中，所有位于当前时间前面的奖品数量都加入到奖品池中，然后更新发奖计划，把发奖计划中这些时间戳和对应奖品数量删除掉

#### 分布式锁优化抽奖次数

这个情景是真难想象吧= =

也就是说, 多次点击按钮, 因为网络延迟, 导致一次抽奖机会触发了多次抽奖? 还是说多次抽奖机会呢?

[Docs](https://ls8sck0zrg.feishu.cn/wiki/HOrdwMqsTi67ujkZFICcdRpwnCG)



## 实战篇

TODO

## 面试篇

