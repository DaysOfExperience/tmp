# 什么是事务

**事务就是一组DML语句的组成, 这些语句在逻辑上存在相关性, 这一组DML语句要么全部成功，要么全部失败，是一个整体。**

（DML，数据操纵语言，用来对数据进行操作，代表指令： insert，delete，update，select）

**事务指逻辑上的一组操作（一组SQL）**，这组操作要么全部成功，要么全部失败。

> 事务就是要做的或所做的事情，主要用于处理操作量大，复杂度高的数据。比如一种场景：你毕业了， 学校的教务系统后台MySQL中，不再需要你的数据，要删除你的所有信息(一般不会:) ), 那么要删除你的基本信息(姓名，电话，籍贯等)的同时，也删除和你有关的其他信息，比如：你的各科成绩，你在校表现，甚至你在论坛发过的文章等。**这样，就需要多条 MySQL 语句构成，那么所有这些操作合起来，就构成了一个事务。**
>
> 一个 MySQL 数据库，可不止一个事务在运行，同一时刻，甚至有大量的请求被包装成事务，在向 MySQL 服务器发起事务处理请求。而每条事务包含一条SQL或多条SQL，这样**如果大家都访问同样的表数据，在不加保护的情况，就绝对会出现问题。**甚至，因为事务由多条 SQL 构成，那么，也会存在事务执行到一半出错的情况，那么已经执行的怎么办呢？
>
> 上方所说的多个事务同时被MySQL服务器处理（多个事务的SQL被MySQL服务器并发执行），在不加保护的情况下，会出问题。并且也可能出现事务执行一半出错的情况，所以，必须解决这些问题。而起初MySQL服务端并不解决这些问题，这些问题应由MySQL的使用者来解决，也就是应用程序访问数据库时，我们需要考虑这些潜在问题的存在。
> 而后面事务被 MySQL 编写者设计出来, 本质是为了当应用程序访问数据库的时候, 事务能够简化我们的编程模型, 不需要我们去考虑各种各样的潜在错误和并发问题.（比如当我们使用事务时, 要么提交, 要么回滚。我们不会去考虑网络异常或服务器宕机时，同时更改一个数据怎么办，以及其他并发问题）**因此事务本质上是为了应用层服务的. 而不是伴随着数据库系统天生就有的.**
>
> 在 MySQL 中只有使用了 InnoDB 数据库引擎的数据库或表才支持事务， MyISAM 不支持。

# 事务的四个属性

因此，MySQL的InnoDB数据库引擎为了简化应用层应用程序的编写，避免事务在不加保护的情况下的一些潜在并发问题或非原子性的问题。使得事务具有四个属性ACID：原子性（atomicity）一致性（consistency）隔离性（isolation）持久性（durability）

- **原子性：**又称不可分割性。一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。
  若事务在执行过程中发生错误，会自动回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

> 例如：我们去ATM机取钱，流程如下插入银行卡，1. 验证密码是否正确 2. 从远程银行的数据库中获取当前账户的信息 3. 用户在ATM机上输入想要提取的金额 4. 从远程银行的数据库中更行账户信息 5. ATM出款 6. 用户取款
>
> 上述的过程就应该视为一个具有原子性的操作，即要么全都发生，要么就不发生。因为不可以扣账户中的钱，ATM却不出钞票，又或者是出了钞票，我的账户却没发生变化，又或者银行卡插入之后出了问题退不出来了，这种情况是不容许发生的。

- **一致性：**在事务开始之前和事务结束以后，**数据库的完整性没有被破坏。**事务操作前与操作后的**状态始终一致**。

- **隔离性：**又称独立性，数据库允许多个**并发**事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
  事务隔离性分为不同级别，包括读未提交（ Read uncommitted ）、读提交（ read committed ）、可重复读（ repeatable read ）和串行化 （ Serializable ）
- **持久性：**事务一旦提交（处理结束），对数据的修改就是永久的，即便系统故障也不会丢失。

# 事务的使用

**事务的提交**方式常见的有两种：1. 自动提交 2. 手动提交

```mysql
-- 自动提交
mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.00 sec)

mysql> set autocommit=0;
Query OK, 0 rows affected (0.00 sec)

mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | OFF   |
+---------------+-------+
1 row in set (0.00 sec)
-- 手动提交
mysql> start transaction;  -- 开启事务的方法1
mysql> begin;			   -- 开启事务的方法2
mysql> savepoint sp1;	   -- 创建保存点sp1
mysql> savepoint sp2;
mysql> release savepoint sp1; -- 删除保存点sp1
mysql> rollback to sp1;    -- 回滚到保存点sp1
mysql> rollback;		   -- 回滚到事务起始
select @@tx_isolation;	   -- 获取当前隔离级别
set global transaction isolation level READ UNCOMMITTED;   -- 设置隔离级别，需要重启终端，才能生效
```

将事务的隔离级别由默认的Repeatable Read改为Read Uncommitted（读未提交，最低的隔离级别，相当于没有隔离性，便于测试），然后进行测试，得出以下结论。

- 开始事务可以是`start transaction`或者`begin`，只要输入begin或者start transaction，事务便必须要通过commit提交，才会结束事务并持久化，与是否设置autocommit无关。
- 事务可以手动回滚到指定保存点`rollback to sp2`，同时，当出现异常`ctrl+d`，MySQL会自动回滚（事务的原子性）
- 如果没有设置保存点，也可以回滚，只能回滚到事务的开始。直接rollback(前提是事务还没有提交)
- 如果一个事务被提交了（commit），则不可以回退（rollback）
- InnoDB 支持事务， MyISAM 不支持事务
- 关闭autocommit，用户将会一直处于某个事务中，只有commit或rollback后才会结束当前事务，并自动重新开启一个新事务。
- 开启autocommit，则每执行一条 SQL 语句，事务都会自动提交一次（autocommit）。也就是若不begin，则每一条SQL都是一个事务。
- 所以综上，可以理解为MySQL时刻都是处于事务中，因为不管是autocommit还是commit，都会自动开启一个新的事务。

从测试的例子可以看出，事务的**原子性**（出现异常自动回滚，commit之后无法rollback）和**持久性**（commit之后，无法rollback，且对数据的修改是永久的，即便系统故障也不会丢失）

那么，隔离性和一致性呢？

# 事务的隔离性

## 理解隔离性

- MySQL服务端可能会同时被多个客户端进程(线程)访问，访问以事务的方式进行。
- 一个事务可能由多条SQL构成，也就意味着，任何一个事务，对于mysqld来说，都有执行前，执行中，执行后的阶段。（而所谓的原子性，其实就是让用户层，要么看到执行前，要么看到执行后。执行中出现问题，可以随时回滚。所以单个事务，对用户表现出来的特性，就是原子性。）但，毕竟所有事务对于mysqld而言都要有个执行过程，那么在多个事务各自执行多个SQL的时候，就还是有可能会出现互相影响的情况。比如：多个事务同时访问同一张表，甚至同一行数据。
- **数据库中，为了保证事务执行过程中尽量不互相干扰，从而避免一些并发问题，就需要了一个重要特征：隔离性。**
- **数据库中，允许事务受不同程度的干扰，就有了一种重要特征：隔离级别。**

> 隔离级别最低时，等同于隔离性最差，或者没有隔离性。而隔离级别最高时，可以理解为隔离性最强。隔离性并非只处于没有隔离性和有隔离性两个状态，还根据不同程序的隔离性而划分出隔离级别。

## 隔离级别

### 读未提交-Read Uncommitted

在该隔离级别，**所有的事务都可以看到其他事务没有提交的执行结果。**(这里的执行结果指的是insert，delele，update)（实际生产中不可能使用这种隔离级别的），但是因为**相当于没有任何隔离性**，会**有很多并发问题**，如脏读，幻读，不可重复读等，我们上面为了做实验方便，用的就是这个隔离性。

### 读已提交-Read Committed

该隔离级别是大多数数据库的默认的隔离级别（不是MySQL默认的）。

它满足了隔离的简单定义:**一个事务只能看到其他已经提交的事务所做的改变。**这种隔离级别解决了脏读问题，但还是会引起不可重复读问题, 但是因为不可重复读本身并不是一个大问题，所以为了兼顾到性能，大部分数据库都会容许这种问题的产生，因此是大多数的数据库的默认隔离级别。

### 可重复读-Repeatable Read

> 这是MySQL中InnoDB默认的隔离级别

**它确保同一个事务在执行中多次读取数据时，会看到同样的数据行。**

也就是其他事务commit的数据也读不到，也就是保证多次读读到的数据一致，即可重复读。只有当此事务commit之后才会读到其他事务commit的数据。

> 对于其他数据库来说，RR隔离级别解决了不可重复读的问题，但是会有幻读问题。
> MySQL的InnoDB在RR级别的时候，不仅解决了不可重复读问题, 还解决了幻读问题(解决的方式是用Next-Key锁 (GAP+行锁)解决的。而对于其他数据库来说，RR级别可能并未解决幻读问题，解决幻读问题需要将隔离级别升级为可串行化）
> 可以理解为MySQL的可重复读实现的更严格，从而消除了幻读问题。(不同数据库对于可重复读的实现程度是不同的)

### 可串行化-Serializable

这是事务的最高隔离级别，它**通过强制事务排序，使事务之间不可能相互冲突**， 从而解决了幻读问题。它在每个读的数据行上加上共享锁。所以可能会导致大量的超时现象和锁竞争 （这种隔离级别太极端，实际生产基本不使用）

（下图中，在MySQL的InnoDB存储引擎下，RR - 幻读是X，也就是InnoDB的RR解决了幻读问题。）

![image-20230828164122099](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230828164122099.png)

> 读未提交是最低的隔离级别，可能会导致很多事务的并发问题，主要是三个：脏读，不可重复读，幻读。而随着每一次隔离级别的提升，都会解决一个并发问题。
>
> 因为读未提交相当于没有任何隔离性，故并发问题很多，所以一般实际生产中不采用。串行化虽然全部解决，但是一定意味着并发度最低，较极端，所以实际生产中也一般不采用。

总结：

- **需要注意的是隔离级别越高，事务请求的锁也就越多，保持锁的时间也就越长。所以隔离性越强，并发的效率也就越低。**
- 其中隔离级别越严格，安全性就越高，但数据库的并发性能也就越低，往往需要在两者之间找一个平衡点。（因此数据库提供了多个隔离级别，而不是仅读未提交和可串行化）
- mysql 默认的隔离级别是可重复读，一般情况下不要修改。
- 上面的例子可以看出，事务也有长短事务这样的概念。

## 事务并发带来的问题

### 脏读

一个事务在执行中，读到另一个执行中事务的更新(或其他操作)但是未commit的数据，这种现象叫做脏读 (dirty read)

比如update，delete，insert又或者是rollback

![image-20230828165531883](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230828165531883.png)

> 例如上图，会话B在第一次查看表时表中只有一条数据，但是在第五阶段中会话A向表中插入了另一条数据，且此时会话A的事务并未commit，而会话B在读取的时候得到的结果就不再一样，因为它读取到了脏数据。即，事务B读取到了事务A未提交的数据。

脏读问题只要隔离级别高于最低的读未提交就能解决。

### 不可重复读

不可重复读指的是**一个事务在执行过程中多次读取同一行数据，但是读取到的数据不一样（主要针对同一行数据）**。导致这一问题的主要原因就是一个**事务读取到了其他事务已提交的数据。**

例如以下情况

1. 事务A读取某账户的数据，显示有500元
2. 事务B将其他账户的300元转给该账户，并提交事务
3. 事务A再次读取该账户，此时显示里面有800元。

由于其他事务的干扰，对于事务A来说，两次读取的数据不一样。（读取到了其他事务已经提交的数据）

因为不可重复读读到的是已经提交的数据，由于其本身并不会带来很大的问题，所以大部分数据库厂商都会允许这种情况的发生，将默认隔离级别设置为 READ COMMITTED - 读已提交（解决脏读问题，存在不可重复读问题）

### 幻读（虚读）

幻读指在同一事务执行过程中，用同样的操作读取两次，得到的**记录行的数量**不一样。（针对同一个范围的数据）

幻读问题发生在同一事务的两个不同时间点执行相同的查询，但由于其他事务的插入、更新或删除操作，返回了**不同数量的数据行。**

![image-20230828170454585](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230828170454585.png)

在事务A的第一次查询中，a大于2的只有一行，而由于事务B插入了新数据后，对于事务A而言就凭空多出来了一行，像出现了幻觉一样。

### 丢失更新

丢失更新就是**一个事务的更新操作会被另外一个事务的更新操作所覆盖，从而导致数据的不一致**。

例如以下案例

1. 事务A将行记录r更新为1，但是事务A并未提交
2. 同时，事务B将行记录r更新为2，事务B未提交
3. 事务A提交
4. 事务B提交

此时由于B将A的修改覆盖，导致A虽然提交，但是更新却丢失了，只剩下了B的更新。

但是在当前数据库的任何隔离级别下，都不会导致理论意义上的丢失更新问题，即使是隔离级别最低的Read Uncommitted，也由于**加锁保护**，所以事务B的修改操作会被阻塞，直到事务A提交。

这也就是为什么通常大家讨论的只有脏读，不可重复读，幻读的原因。

---

**小结**

不管是三个并发问题，还是4个隔离级别，会发现，都是围绕着一个字：读。

脏读：读到了其他事务未commit的数据；不可重复读：读到了其他事务commit的数据；幻读：两次读读到的记录行数不一样；

读未提交：可以读到其他事务未commit的数据（最低级的脏读问题也存在）；读已提交：一个事务只会读到其他事务已commit的数据，未commit的读不到（解决脏读）；可重复读：其他事务已commit的数据也读不到，即可以重复读，多次读取同一行的数据一致（解决不可重复读）；可串行化：解决了幻读问题。

**区分不可重复读和幻读**

不可重复读：两个不同时间点读取同一行数据时，发现数据已经发生了改变。也就是其他事务的update操作被读到了。**重点是两次读同一行, 读到了不同数据。**

1. 事务 A 开始，并读取某一行的数据。
2. 事务 B 开始，更新了该行的数据。
3. 事务 A 再次尝试读取相同的行，**发现数据与之前不同。**

幻读：两个不同时间点执行相同的查询，但由于其他事务的插入、更新或删除操作，返回了**不同数量的数据行。重点是读到了不同数量的数据行！**

1. 事务 A 开始，并执行一个范围查询，返回符合条件的数据行。
2. 事务 B 开始，插入了符合事务 A 查询条件的新数据行。
3. 事务 A 再次执行相同的范围查询，发现返回的**数据行数量比之前多。**

**不可重复读问题关注的是在同一事务两次读取读取到相同数据的不同版本，可能是由于其他事务的更新造成的。幻读问题则关注的是在同一事务内执行两次相同的查询，但返回的数据记录的行数量不同，可能是由于其他事务的插入、更新或删除操作造成的。**

解决这些问题的方法之一是使用适当的隔离级别，例如"可重复读"或"串行化"。这些隔离级别提供了不同的并发控制机制，以减少或避免这些数据一致性问题的发生。

> 背景：事务A事务B并发执行，A对table x执行update和insert两种语句，在commit之后，对于事务B来说，在RR可重复读的隔离级别下，都看不到事务A的update和insert对表x的修改。
>
> --多次查看，发现终端A在对应事务中insert的数据，在终端B的事务周期中，也没有什么影响，也符合可重复读的特点。但是，一般的数据库在可重复读情况的时候，无法屏蔽其他事务insert的数据(为什么？因为隔离性实现是对数据加锁完成的，而insert待插入的数据因为并不存在，所以一般加锁无法屏蔽这类问题)，会造成虽然大部分内容是可重复读的，但是insert的数据在可重复读隔离级别下仍被读取出来，导致多次查找时，会**多查找出来新的记录**，就如同产生了幻觉。这种现象，叫做**幻读** (phantom read)。很明显，**MySQL在RR级别的时候，是解决了幻读问题的**(解决的方式是用Next-Key锁 (GAP+行锁)解决的。这块比较难。

# 事务的一致性

- 事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库只包含事务成功提交的结果时，数据库处于一致性状态。如果系统运行发生中断，某个事务尚未完成而被迫中断，而该未完成的事务对数据库所做的修改已被写入数据库，此时数据库就处于一种不正确（不一致）的状态。因此一致性主要是通过原子性来保证的。
- **一致性和用户的业务逻辑强相关，一般MySQL提供技术支持，但是一致性还是要用户正确的业务逻辑做支撑**，也就是，一致性，是由用户决定的。
- 而技术上，通过AID保证C：通过原子性，隔离性，持久性保证一致性。

> 理解：就好比我们此时有用户A和用户B，他们的余额分别为300元和700元，此时两人总金额为1000元。此时若是用户B向用户A转账200元，则两者的此时都有500元，总金额还是1000元。
>
> 也就是说，无论我们两个怎么转账，总金额它只会是1000，既不会多，也不会少。这就是在事务操作前后，数据库的状态始终一致。倘若钱总数多了或者少了，都代表着事务将数据库从一种状态变为了另外一种状态，此时就不再符合一致性了。
>
> 而这个一致性并不能完全由数据库保证，比如业务逻辑中的SQL实现A用户向B用户转账时：A用户减少200，但是没有给B用户加200的SQL，则这样的事务也会破坏数据库的一致性。所以说一致性与用户的业务逻辑强相关。

# 理解事务的隔离性2

> [MySQL - MySQL InnoDB的MVCC实现机制](https://pdai.tech/md/db/sql-mysql/sql-mysql-mvcc.html)

## 数据库多事务并发的三种场景

- **读读并发** ：不存在任何问题，也不需要并发控制

- **读写并发** ：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读

- **写写并发** ：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失

## 读写并发与MVCC

MySQL 的InnoDB中实现了事务（多版本并发控制MVCC+锁）， 其中通过MVCC解决隔离性问题。具体而言，**MVCC就是为了实现读-写冲突不加锁，而这个读指的是快照读, 而非当前读, 当前读实际上是一种加锁的操作（是悲观锁的实现）** 

**MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发读写性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞地并发读。**

MVCC - 多版本并发控制是一种用来**解决读-写冲突**的**无锁并发控制**

MVCC的大致实现思路为：为事务分配单向增长的事务ID，为记录的每个修改保存一个版本，版本与事务ID关联。

MVCC 可以为数据库解决以下问题 / 有如下的作用

1. **在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能**。（注意，仅限于快照读）
2. 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题。

### MVCC

MVCC - Multi-Version Concurrency Control - 多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它主要是依赖记录中的 **4个隐式字段**，**undo日志** ，**Read View** 来实现的。

#### 记录的4个隐藏列字段

也就是说，InnoDB存储引擎下的每一个表除了包含我们自定义的字段外，都会有四个隐藏列字段（数据库隐式定义）

- `DB_ROW_ID` : 6 byte，**隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以`DB_ROW_ID`为主键产生一个聚簇索引**

- `DB_TRX_ID`：6 byte，**最近修改/插入该记录的事务ID **  (MVCC的核心)
- `DB_ROLL_PTR` : 7 byte，**回滚指针，指向这条记录的上一个版本**
- `DELETED_BIT`: 1byte, **记录是否被删除的flag标记位**. 记录被删除并不代表真的删除，而是删除flag变了。
  （也就是说，当删除一条记录时，并非直接去聚簇索引中将该记录行删除，因为记录在聚簇索引中本身就是有序排列的（按照主键，无论是user指定的主键还是隐藏主键`DB_ROW_ID`），如果真的直接修改聚簇索引，那么相当于顺序表删除，时间复杂度很高，所以删除时只是将flag字段修改。等持久化落盘时才会根据flag字段进行进一步修改表的记录结构）

#### undo日志

> MySQL 将来是以服务进程的方式，在内存中运行的。我们之前所讲的所有机制：索引，事务，隔离性，日志等，都是在内存中完成的，即在MySQL内部的相关缓冲区`buffer pool`中，保存相关数据，完成各种判断操作。然后在合适的时候，将相关数据刷新到磁盘当中的。
> 所以，我们这里理解undo log，可以简单理解成 MySQL 中的一段内存缓冲区，用来保存日志数据的就行。（可以理解为undo log为buffer pool的一部分）

Undo log 的用途

1. 事务回滚：保证事务的**原子性和一致性**，当事务进行rollback回滚的时候可以用undo log的数据进行恢复。

2. MVCC读写并发：**在MVCC多版本控制中，快照读通过读取undo log的历史版本数据从而实现读写并发**。

**InnoDB把这些为了回滚而记录的这些东西称之为undo log。**(当然另一个作用就是, 配合实现MVCC)这里需要注意的一点是，由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo log。undo log主要分为3种：

- **Insert undo log** ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。
- **Update undo log**：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。
- **Delete undo log**：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。 
  - 删除操作都只是设置一下老记录的DELETED_BIT，并不真正将过时的记录删除。
  - 为了节省磁盘空间，InnoDB有专门的purge线程来清理DELETED_BIT为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的DELETED_BIT为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。

**基于记录四个隐藏列字段+undo log简单模拟MVCC-多版本并发控制**

现在有一个事务10，对student表中记录进行修改(update)：将name(张三)改成name(李四)。

1. 事务10，因为要修改，所以要先给该记录加行锁。
2. 修改前，先将该行记录拷贝到undo log中，所以，undo log中就有了一行副本数据-历史记录。(原理就是写时拷贝) 
3. 所以现在 MySQL 中有两行同样的记录。现在修改原始记录中的name，改成 '李四'。并且修改原始记录的隐藏字段`DB_TRX_ID`为当前事务10的ID（我们默认从10开始，之后递增）而原始记录的回滚指针`DB_ROLL_PTR`列，里面写入`undo log`中副本数据的地址，从而指向副本记录，表示我的上一个版本就是它。
4. 事务10提交，释放锁。

备注：此时，最新的记录是’李四‘那条记录。 

现在又有一个事务11，对student表中记录进行修改(update)：将age(28)改成age(38)。

1. 事务11，因为也要修改，所以要先给该记录加行锁。
2. 修改前，先将该行记录拷贝到undo log中，所以，undo log中就又有了一行副本数据。此时，新的副本，我们采用头插方式，插入undo log。
3. 现在修改原始记录中的age，改成38。并且修改原始记录的隐藏字段`DB_TRX_ID`为当前事务11的 ID。而原始记录的回滚指针 `DB_ROLL_PTR` 列，里面写入undo log中副本数据的地址，从而指向副本记录，即表示我的上一个版本就是它。 
4. 事务11提交，释放锁。

最终，这两次update所形成的最终结果如图：聚簇索引中记录的是最新的记录，而历史记录在undo log中，它们通过`DB_ROLL_PTR`字段相连，形成版本链。

![image-20230829143337929](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230829143337929.png)

这样，我们就有了一个基于链表结构的记录的历史版本链。所谓的回滚，无非就是用历史数据，覆盖当前数据。 上面的一个一个版本，我们可以称之为一个一个的快照。

那么，select呢？select当然不会维护多版本，不用进行版本控制，因为select仅读，不写，不会对数据进行修改。
但是select有一个问题：select读取时, 某记录若有多个历史版本, 则读取哪个版本的记录? 是读取最新的版本呢？还是读取历史版本？
先区分当前读和快照读

**当前读 vs 快照读**

**当前读：读取最新版本的记录，就是当前读。**增删改，都叫做当前读。select也有可能是当前读，比如：`select lock in share mode`(共享锁) `select for update` `update` `insert ` `delete`(排他锁)
读取时要保证其他并发事务不能修改当前记录，**因此要对读取的记录进行加锁**.

**快照读：读取历史版本(一般而言)，就叫做快照读。**(也可能是最新版本)
不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读, 即串行的隔离级别下仅支持当前读；

**在多个事务同时删改的时候，都是当前读，是要加锁的**。那同时有select过来，如果是当前读（读取最新版记录），也需要加锁. **但如果是快照读，读取历史版本的话，是不受加锁限制的。也就是可以并行执行！提高了效率，即MVCC的意义所在。**（和最初呼应了）

**当前读，快照读和MVCC的关系**

- 准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。仅仅是一个理想概念
- 而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。
- 而相对而言，当前读就是悲观锁的具体功能实现

区分完快照读与当前读之后, 现在的问题依旧是: 在select进行快照读时, 应该读取记录的众多版本中的哪个版本? 用到的就是Read View

#### Read View

**Read View就是事务进行快照读操作的时候生产的读视图 (Read View)**（注意是进行快照读操作时产生read view，而不是事务开始时），在该事务执行快照读的那一刻，会生成数据库系统当前的一个快照，记录/维护系统当前活跃的事务的ID(其实就是没有commit的)
(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)

**Read View 在 MySQL 源码中,就是一个类，是用来配合快照读进行可见性判断的。 即当某个事务执行快照读的时候, 创建一个 Read View 读视图，通过它来判断当前事务能够看到哪个版本的数据**

> Read View遵循一个可见性算法，主要是将最新记录中的DB_TRX_ID取出来，如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的下一版本的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的记录就是当前事务能看见的"最新版本"
>
> 具体如何用DB_RTX_ID与ReadView的属性作比较看是否满足可见性，看下方

```c++
class ReadView {
	// 省略...
private:
	/** 高水位，大于等于这个ID的事务均不可见*/
	trx_id_t m_low_limit_id;
    /** 低水位：小于这个ID的事务均可见 */
	trx_id_t m_up_limit_id;
	/** 创建该 Read View 的事务ID*/
	trx_id_t m_creator_trx_id;
	/** 创建视图时的活跃事务id列表*/ //未提交事务ID列表，用来维护Read View生成时刻，系统正活跃的事务ID
	ids_t m_ids;
    
	/** 配合purge，标识该视图不需要小于m_low_limit_no的UNDO LOG，
	* 如果其他视图也不需要，则可以删除小于m_low_limit_no的UNDO LOG*/
	trx_id_t m_low_limit_no;
	/** 标记视图是否被关闭*/
	bool m_closed;
	// 省略...
};
```

- `up_limit_id`            // 记录m_ids列表中最小的事务ID
- `low_limit_id`          // ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1（注意，这里并非一定是m_ids中的最大ID+1）
- `creator_trx_id`      // 创建该ReadView的事务ID

我们在实际读取数据的历史版本链的时候，是能读取到每一个版本的记录对应的事务ID的，即：记录的`DB_TRX_ID` 。

所以现在的问题就是，根据当前快照读的`ReadView`和版本链中的某一个记录的`DB_TRX_ID`判断当前快照读应不应该读到这个版本的记录。本质就是进行可见性的判断！

![image-20230829151908796](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230829151908796.png)

进行快照读的select时，会生成ReadView，然后会对记录的版本链进行遍历判断，当找到符合条件的记录时，即终止。

具体来说，在对记录的某版本进行判断时：

1. 若creator_trx_id == DB_TRX_ID则表示该版本的记录就是此事务修改的，则可见。或者当DB_TRX_ID < up_limit_id时，表示在进行快照读并形成ReadView时，该记录对应的事务已经commit了，则可见
2. 若DB_TRX_ID >= low_limit_id，则表示这个版本的记录对应的事务是在形成ReadView快照之后才出现的，则不可见
3. 若DB_TRX_ID不小于up_limit_id也不>=low_limit_id，则只有两种可能：1. 在m_ids中 2. 不在m_ids中。
   1. 若在m_ids中，表示在快照读形成读视图ReadView时，该版本的记录对应的事务与此当前事务正在并发执行（这个事务还在活跃，还没有Commit）。则不可见
   2. 若不在m_ids中，表示对应事务已经commit了（这个事务在Read View生成之前就已经Commit了），则可见

> 理解一下DB_TRX_ID < up_limit_id 和 DB_TRX_ID不在m_ids中 两者的区别：比如3567事务并发执行。当前快照读形成读视图的事务是5号事务，则up_limit_id为3，low_limit_id为8。而形成快照读时，4号事务已经commit了，那么此时4就是处于不在m_ids中且不小于up_limit_id的状态。但是4事务在形成快照读时也已经commit了，所以属于可见的！
>
> 4号事务与1，2号事务有什么不同吗？其实没什么不同，无非4号事务前的3号事务还没commit。而124在形成快照时，都已经commit了。

**简单来说，只要形成读视图时，记录对应的DB_TRX_ID事务已经commit了，则可见。**

<img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230829154152325.png" alt="image-20230829154152325" style="zoom:67%;" />

上图为利用快照读时形成的ReadView对版本链中的记录进行可见性判断的函数，此函数为ReadView的成员函数，所以可以直接访问数据成员。其实就是对版本链中的记录进行遍历判断，若返回为true则表示可见，并终止遍历。

#### 举个例子

模拟MVCC整体流程

> <img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230829160121465.png" alt="image-20230829160121465" style="zoom:50%;" />
>
> ![image-20230829160152883](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230829160152883.png)
>
> 事务4：修改name(张三) 变成name(李四) 
>当 事务2 对某行数据执行了 快照读 ，数据库为该行数据生成一个 Read View 读视图
> 
> ```mysql
>//事务2此次快照读的 Read View
> m_ids;       // 1,3
> up_limit_id; // 1
> low_limit_id; // 4 + 1 = 5，原因：ReadView生成时刻，系统尚未分配的下一个事务ID
> creator_trx_id // 2
> ```
> 
> 我们的事务2在快照读该行记录的时候，就会拿该行记录的 DB_TRX_ID 去跟ReadView中的up_limit_id,low_limit_id和活跃事务ID列表(trx_list) 进行比较，判断结果为当前事务2能看到该记录的版本。
>
> ```mysql
>-- 事务2的 Read View
> m_ids; // 1,3
> up_limit_id; // 1
> low_limit_id; // 4 + 1 = 5，原因：ReadView生成时刻，系统尚未分配的下一个事务ID
> creator_trx_id // 2
> -- 事务4提交的记录对应的事务ID
> DB_TRX_ID=4
> -- 比较步骤
> DB_TRX_ID（4）< up_limit_id（1） ? 不小于，下一步
> DB_TRX_ID（4）>= low_limit_id(5) ? 不大于，下一步
> m_ids.contains(DB_TRX_ID) ? 不包含，说明，事务4不在当前的活跃事务中。
> -- 结论
> 故，该版本的记录对事务2在快照读时是可见的。
> 所以事务2能读到的最新版本的数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本。
> ```

上方介绍了MVCC的实现原理的三个重要组成部分，三个隐藏列字段+undo log完成版本控制，而ReadView为当事务进行快照读时生成该视图，然后对版本链中的记录逐个进行可见性判断。

但是需要注意的是，其实MVCC的介绍过程中，并没有提及具体的隔离级别。那么，具体的RR和RC是如何通过MVCC实现的呢？

### RR vs RC

首先先来一个测试，体验一下当前读和快照读在RR级别下的区别，以及稍微进一步地理解一下RR隔离级别。

测试环境：RR隔离级别

#### 测试

----

测试1

| 事务A操作                                      | 事务A操作描述 | 事务B操作                                 | 事务B操作描述                                     |
| ---------------------------------------------- | ------------- | ----------------------------------------- | ------------------------------------------------- |
| begin                                          | 开启事务      | begin                                     | 开启事务                                          |
| select * from account;                         | 快照读查询    | select * from account;                    | 快照读查询                                        |
| update account set name = '里斯' where id = 1; | 更新          |                                           |                                                   |
| commit                                         | 提交事务      |                                           |                                                   |
|                                                |               | select * from account;                    | select 快照读 ,没有读取到事务A的更新              |
|                                                |               | select * from account lock in share mode; | select lock in share mode当前读 , 读到事务A的更新 |

测试2

| 事务A操作                                      | 事务A操作描述 | 事务B操作                                 | 事务B操作描述                                     |
| ---------------------------------------------- | ------------- | ----------------------------------------- | ------------------------------------------------- |
| begin                                          | 开启事务      | begin                                     | 开启事务                                          |
| select * from account;                         | 快照读查询    |                                           |                                                   |
| update account set name = '里斯' where id = 1; | 更新          |                                           |                                                   |
| commit                                         | 提交事务      |                                           |                                                   |
|                                                |               | select * from account;                    | select 快照读 ,读取到事务A的更新                  |
|                                                |               | select * from account lock in share mode; | select lock in share mode当前读 , 读到事务A的更新 |
|                                                |               | select * from account;                    | select 快照读 ,读取到事务A的更新                  |

**现象：测试2中，我们发现事务B在事务Acommit之后，再进行快照读时是读取到了事务A的更新的，其实这个有点不符合我们之前的意料。但是这依旧是符合可重复读这个要求的。**

用例1与用例2唯一区别仅仅是用例1的事务B在事务A更新数据前快照读过一次数据，而用例2的事务B在事务A修改数据前没有进行过快照读。差别就是事务B第一次快照读的时机，是事务Acommit前还是后。

结论：

- **事务中快照读的结果 非常依赖 该事务 首次出现快照读 的地方，即某个事务中首次出现快照读的时机，决定了该事务后续快照读的结果。（前提是RR隔离级别下）**
- 测试之后发现：delete，insert同样如此。（插一句，其他数据库如果insert的话可能产生幻读，而MySQL的RR解决了幻读，但并不是依靠MVCC）

#### RR 与 RC的本质区别

**正是Read View生成规律的不同，从而造成RC, RR级别下快照读的结果的不同。**（注意这里的生成规律指的不是第一次快照读的时机）

RR

- 在**RR级别下**的某个事务的对某条记录的**第一次快照读会创建一个快照即Read View**, 将当前系统活跃的其他事务记录起来。**此后在该事务进行快照读的时候，还是使用的是同一个Read View**，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，**所以，对其他事务的commit的修改不可见；**（其实这也是RR对于RC的改动）
  （其实本质就是，后续快照读的时候，可能有的事务已经在第一次快照读生成读视图 之后commit了，但是由于后续快照读的时候依旧使用的是第一次的ReadView，所以对应的已commit的事务依旧视作未commit，也就是在活跃队列中，故其commit的修改不可见(因为读视图中仍记录的这个事务是活跃的)，即可重复读）
- 即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的已commit的事务所做的修改均是可见（事务的修改已经commit）。（ReadView进行可见性判断的规则）

RC

- 而在**RC级别下**的事务中，**每次快照读都会新生成一个快照和Read View**, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因。（<u>因为在其他事务commit之后再次快照读时，是新生成了一个ReadView</u>，所以，此时commit的事务的更新（记录）通过ReadView的可见性判断，是可见的（因为已经commit了））

总之

- 在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取/使用的都是同一个Read View。
- **正是RC每次快照读，都会形成Read View，所以，RC才会有不可重复读问题。**
  **正是RR每次快照读都是使用第一次快照读生成的ReadView，所以，RR才可重复读。**

---

> **其实，现在你会发现。之前说MVCC解决读写并发，而严格来说, MVCC解决的是快照读与写之间的并发问题。而当前读与写的并发问题是通过锁来解决的。**

## 读读并发

不讨论

## 写写并发

不讨论

## 小结一下

总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：

- **MVCC + 悲观锁** MVCC解决读写冲突，悲观锁解决写写冲突
- **MVCC + 乐观锁** MVCC解决读写冲突，乐观锁解决写写冲突

这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题
