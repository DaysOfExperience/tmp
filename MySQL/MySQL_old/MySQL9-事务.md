搞清楚MVCC多版本并发控制和RR RU的关系

其实RR RU隔离级别, 要想解决脏读不可重复读的这些问题, 完全可以加锁, 但是因为加锁时读写并发性能不好, 所以采用了读写性能更好的MVCC.   这样一来既提升了读写并发的性能, 又解决了隔离性问题, 实现了隔离级别



### 什么是事务

事务就是一组DML语句的组成, 这些语句在逻辑上存在相关性, 这一组DML语句要么全部成功，要么全部失败，是一个整体。

（DML，数据操纵语言，用来对数据进行操作，代表指令： insert，delete，update，select）

事务指逻辑上的一组操作（一组SQL），这组操作要么全部成功，要么全部失败。

> 事务就是要做的或所做的事情，主要用于处理操作量大，复杂度高的数据。比如一种场景：你毕业了， 学校的教务系统后台MySQL中，不再需要你的数据，要删除你的所有信息(一般不会:) ), 那么要删除你的基本信息(姓名，电话，籍贯等)的同时，也删除和你有关的其他信息，比如：你的各科成绩，你在校表现，甚至你在论坛发过的文章等。**这样，就需要多条 MySQL 语句构成，那么所有这些操作合起来，就构成了一个事务。**
>
> 一个 MySQL 数据库，可不止一个事务在运行，同一时刻，甚至有大量的请求被包装成事务，在向 MySQL 服务器发起事务处理请求。而每条事务包含一条SQL或多条SQL，这样**如果大家都访问同样的表数据，在不加保护的情况，就绝对会出现问题。**甚至，因为事务由多条 SQL 构成，那么，也会存在事务执行到一半出错的情况，那么已经执行的怎么办呢？
>
> 所以，必须解决这些问题。而起初MySQL服务端并不解决这些问题，这些问题应由MySQL的使用者来解决，也就是应用程序访问数据库时，我们需要考虑这些潜在问题的存在。
> 而后面事务被 MySQL 编写者设计出来, 本质是为了当应用程序访问数据库的时候, 事务能够简化我们的编程模型, 不需要我们去考虑各种各样的潜在错误和并发问题.（比如当我们使用事务时, 要么提交, 要么回滚。我们不会去考虑网络异常或服务器宕机时，同时更改一个数据怎么办，以及其他并发问题）**因此事务本质上是为了应用层服务的. 而不是伴随着数据库系统天生就有的.**
>
> 在 MySQL 中只有使用了 InnoDB 存储引擎的数据库或表才支持事务， MyISAM 不支持。

### 事务的使用

**事务的提交**方式常见的有两种：1. 自动提交 2. 手动提交

```mysql
-- 自动提交
mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.00 sec)

mysql> set autocommit=0;
Query OK, 0 rows affected (0.00 sec)

mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | OFF   |
+---------------+-------+
1 row in set (0.00 sec)
-- 手动提交
mysql> start transaction;  -- 开启事务的方法1
mysql> begin;			   -- 开启事务的方法2
mysql> savepoint sp1;	   -- 创建保存点sp1
mysql> savepoint sp2;
mysql> release savepoint sp1; -- 删除保存点sp1
mysql> rollback to sp1;    -- 回滚到保存点sp1
mysql> rollback;		   -- 回滚到事务起始
select @@tx_isolation;	   -- 获取当前隔离级别
set global transaction isolation level READ UNCOMMITTED;   -- 设置隔离级别，需要重启终端，才能生效
```

将事务的隔离级别由默认的Repeatable Read改为Read Uncommitted（读未提交，最低的隔离级别，相当于没有隔离性，便于测试），然后进行测试，得出以下结论。

- 开始事务可以是`start transaction`或者`begin`，只要输入begin或者start transaction，事务便必须要通过commit提交，才会结束事务并持久化，与是否设置autocommit无关。
- 事务可以手动回滚到指定保存点`rollback to sp2`，同时，当出现异常`ctrl+d`，MySQL会自动回滚（事务的原子性）
- 如果没有设置保存点，也可以回滚，只能回滚到事务的开始。直接rollback(前提是事务还没有提交)
- 如果一个事务被提交了（commit），则不可以回退（rollback）
- InnoDB 支持事务， MyISAM 不支持事务
- 关闭autocommit，用户将会一直处于某个事务中，只有commit或rollback后才会结束当前事务，并自动重新开启一个新事务。
- 开启autocommit，则每执行一条 SQL 语句，事务都会自动提交一次（autocommit）。也就是若不begin，则每一条SQL都是一个事务。
- 所以综上，可以理解为MySQL时刻都是处于事务中，因为不管是autocommit还是commit，都会自动开启一个新的事务。

### 事务的四个属性

因此，MySQL的InnoDB数据库引擎为了简化应用层应用程序的编写，避免事务在不加保护的情况下的一些潜在并发问题或非原子性的问题。使得事务具有四个属性ACID：原子性（atomicity）一致性（consistency）隔离性（isolation）持久性（durability）

- **原子性：**又称不可分割性。一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。
  若事务在执行过程中发生错误，会自动回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

- **一致性：**在事务开始之前和事务结束以后，**数据库的完整性没有被破坏。**事务操作前与操作后的**状态始终一致**。

  > **一致性和用户的业务逻辑强相关，一般MySQL提供技术支持，但是一致性还是要用户正确的业务逻辑做支撑**，也就是，一致性，是由用户决定的。 而技术上，通过AID保证C：通过原子性，隔离性，持久性保证一致性。
  >
  > 理解：就好比我们此时有用户A和用户B，他们的余额分别为300元和700元，此时两人总金额为1000元。此时若是用户B向用户A转账200元，则两者的此时都有500元，总金额还是1000元。
  >
  > 也就是说，无论我们两个怎么转账，总金额它只会是1000，既不会多，也不会少。这就是在事务操作前后，数据库的状态始终一致。倘若钱总数多了或者少了，都代表着事务将数据库从一种状态变为了另外一种状态，此时就不再符合一致性了。
  >
  > 而这个一致性并不能完全由数据库保证，比如业务逻辑中的SQL实现A用户向B用户转账时：A用户减少200，但是没有给B用户加200的SQL，则这样的事务也会破坏数据库的一致性。所以说一致性与用户的业务逻辑强相关。

- **隔离性：**又称独立性，数据库允许多个**并发**事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。

- **持久性：**事务一旦提交（处理结束），对数据的修改就是永久的，即便系统故障也不会丢失。

# 事务的隔离性

**理解隔离性**

MySQL服务端可能会同时被多个客户端进程(线程)访问，访问以事务的方式进行。

一个事务可能由多条SQL构成，也就意味着，任何一个事务，对于mysqld来说，都有执行前，执行中，执行后的阶段。（而所谓的原子性，其实就是让用户层，要么看到执行前，要么看到执行后。执行中出现问题，可以随时回滚。所以单个事务，对用户表现出来的特性，就是原子性。）但，毕竟所有事务对于mysqld而言都要有个执行过程，那么在多个事务各自执行多个SQL的时候，就还是有可能会出现互相影响的情况。比如：多个事务同时访问同一张表，甚至同一行数据。

**数据库中，为了保证事务并发执行过程中尽量不互相干扰，从而避免一些并发问题，就需要了一个重要特征：隔离性。**

**数据库中，允许事务受不同程度的干扰，就有了一种重要特征：隔离级别。**

## 隔离级别

- 读未提交-Read Uncommitted

在该隔离级别，**所有的事务都可以看到其他事务没有提交的执行结果。**(这里的执行结果指的是insert，delele，update)（实际生产中不可能使用这种隔离级别的），但是因为**相当于没有任何隔离性，会有很多并发问题**，如脏读，幻读，不可重复读等

- 读已提交-Read Committed

该隔离级别是大多数数据库的默认的隔离级别（不是MySQL默认的）。

它满足了隔离的简单定义:**一个事务只能看到其他已经提交的事务所做的改变。**

> 这种隔离级别解决了脏读问题，但还是会引起不可重复读问题, 但是因为不可重复读本身并不是一个大问题，所以为了兼顾到性能，大部分数据库都会容许这种问题的产生，因此是大多数的数据库的默认隔离级别。

- 可重复读-Repeatable Read

> 这是MySQL中InnoDB默认的隔离级别

**它确保同一个事务在执行中多次读取数据时，会看到同样的数据行。**

也就是其他事务commit的数据也读不到，也就是保证多次读读到的数据一致，即可重复读。只有当此事务commit之后才会读到其他事务commit的数据。

> 对于其他数据库来说，RR隔离级别解决了不可重复读的问题，但是会有幻读问题, 解决幻读问题需要将隔离级别升级为可串行化
> MySQL的InnoDB在RR级别的时候，不仅解决了不可重复读问题, 还解决了绝大部分幻读问题
> 可以理解为MySQL的可重复读实现的更严格，从而消除了幻读问题。(不同数据库对于可重复读的实现程度是不同的)

- 串行化-Serializable

这是事务的最高隔离级别，它**通过强制事务排序，使事务之间不可能相互冲突**， 从而解决了幻读问题。它在每个读的数据行上加上共享锁。所以可能会导致大量的超时现象和锁竞争 （这种隔离级别太极端，实际生产基本不使用）

（下图中，在MySQL的InnoDB存储引擎下，RR - 幻读是X，也就是InnoDB的RR解决了幻读问题。）

![image-20230828164122099](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230828164122099.png)

> 读未提交是最低的隔离级别，可能会导致很多事务的并发问题，主要是三个：脏读，不可重复读，幻读。而随着每一次隔离级别的提升，都会解决一个并发问题。
>
> 因为读未提交相当于没有任何隔离性，故并发问题很多，所以一般实际生产中不采用。串行化虽然全部解决，但是一定意味着并发度最低，较极端，所以实际生产中也一般不采用。

总结：

- **需要注意的是隔离级别越高，事务请求的锁也就越多，保持锁的时间也就越长。所以隔离性越强，并发的效率也就越低。**
- 其中隔离级别越严格，安全性就越高，但数据库的并发性能也就越低，往往需要在两者之间找一个平衡点。（因此数据库提供了多个隔离级别，而不是仅读未提交和可串行化）
- mysql 默认的隔离级别是可重复读，一般情况下不要修改。
- 上面的例子可以看出，事务也有长短事务这样的概念。

## 事务并发带来的问题

- 脏读

一个事务在执行中，读到另一个执行中事务的更新(或其他操作)但是未commit的数据，这种现象叫做脏读 (dirty read)

比如update，delete，insert又或者是rollback

- 不可重复读

不可重复读指的是**一个事务在执行过程中多次读取同一行数据，但是读取到的数据不一样（主要针对同一行数据）**。导致这一问题的主要原因就是一个**事务读取到了其他事务已提交的数据。**

> 因为不可重复读读到的是已经提交的数据，由于其本身并不会带来很大的问题，所以大部分数据库厂商都会允许这种情况的发生，将默认隔离级别设置为 READ COMMITTED - 读已提交

- 幻读（虚读）

幻读指在同一事务执行过程中，用同样的操作读取两次，得到的**记录行的数量**不一样。（针对同一个范围的数据）

幻读问题发生在同一事务的两个不同时间点执行相同的查询，但由于其他事务的插入或删除操作，返回了**不同数量的数据行。**

![image-20230828170454585](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230828170454585.png)

> 背景：事务A事务B并发执行，A对table x执行update和insert两种语句，在commit之后，对于事务B来说，在RR可重复读的隔离级别下，都看不到事务A的update和insert对表x的修改。
>
> --多次查看，发现终端A在对应事务中insert的数据，在终端B的事务周期中，也没有什么影响，也符合可重复读的特点。但是，一般的数据库在可重复读情况的时候，无法屏蔽其他事务insert的数据(为什么？因为隔离性实现是对数据加锁完成的，而insert待插入的数据因为并不存在，所以一般加锁无法屏蔽这类问题)，会造成虽然大部分内容是可重复读的，但是insert的数据在可重复读隔离级别下仍被读取出来，导致多次查找时，会**多查找出来新的记录**，就如同产生了幻觉。这种现象，叫做**幻读** (phantom read)。很明显，**MySQL在RR级别的时候，是解决了幻读问题的**
>
> **RR级别解决幻读问题, 对于其他事务insert的数据, 一种是快照读 一种是当前读, 不能简单的说通过next-key解决的幻读, 因为快照读是通过undo log + read view解决的**

- 丢失更新

丢失更新就是**一个事务的更新操作会被另外一个事务的更新操作所覆盖，从而导致数据的不一致**。 (不加锁多个事务写写并发)

例如以下案例

1. 事务A将行记录r更新为1，但是事务A并未提交
2. 同时，事务B将行记录r更新为2，事务B未提交
3. 事务A提交
4. 事务B提交

此时由于B将A的修改覆盖，导致A虽然提交，但是更新却丢失了，只剩下了B的更新。

但是在当前数据库的任何隔离级别下，都不会导致理论意义上的丢失更新问题，即使是隔离级别最低的Read Uncommitted，也由于**加锁保护**，所以事务B的修改操作会被阻塞，直到事务A提交。(也就是说, MySQL不支持两个事务并发写(记录锁?))

这也就是为什么通常大家讨论的只有脏读，不可重复读，幻读的原因。

---

不管是三个并发问题，还是4个隔离级别，会发现，都是围绕着一个字：读。

> [MySQL - MySQL InnoDB的MVCC实现机制](https://pdai.tech/md/db/sql-mysql/sql-mysql-mvcc.html)





# MVCC

**数据库多事务并发的三种场景**

- **读读并发** ：不存在任何问题，也不需要并发控制

- **读写并发** ：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读, 不可重复读, 幻读

- **写写并发** ：有线程安全问题，可能会存在更新丢失问题

MVCC 可以为数据库解决以下问题 / 有如下的作用

1. 无锁解决读-写冲突: 不加锁，非阻塞地并发读写, 在多个事务并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能。
   （注意，仅限于快照读）  
2. 同时还可以解决脏读，幻读，不可重复读等事务隔离问题. 实现了RR和RU隔离级别
   (可以这样说吗..)

MVCC - Multi-Version Concurrency Control - 多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它主要是依赖记录中的 **4个隐式字段**，**undo日志** ，**Read View** 来实现的。大致实现思路为：为事务分配单向增长的事务ID，为记录的每个修改保存一个版本，版本与事务ID关联。

### 当前读 vs 快照读

**只读取最新版本的记录, 就是当前读.** 增删改，都是当前读。select也可能是当前读，比如：`select lock in share mode`(加共享锁读取最新数据) `select for update` `update` `insert ` `delete`(加排他锁读取最新数据)

**在记录的历史版本链中进行读取，即快照读。**
不加锁的, 普通的select操作就是快照读，即不加锁的非阻塞读；
(快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读, 即串行隔离级别下仅支持当前读)

> **在多个事务同时删改的时候，都是当前读，是要加锁的**。那同时有select过来，如果是当前读（读取最新版记录），也需要加锁. **但如果是快照读，读取历史版本的话，是不受加锁限制的。也就是可以并发执行！提高了效率，即MVCC的意义所在。**

### 记录的4个隐藏列字段

也就是说，InnoDB存储引擎下的每一个表除了包含我们自定义的字段外，都会有四个隐藏列字段（数据库隐式定义）

- `DB_ROW_ID` : 6 byte，隐含的自增ID（**隐藏主键**），如果数据表没有主键，InnoDB会自动以`DB_ROW_ID`为主键产生一个聚簇索引

- `DB_TRX_ID`：6 byte，最近修改/插入该记录的**事务ID**   (MVCC的核心)
- `DB_ROLL_PTR` : 7 byte，**回滚指针**，指向这条记录的上一个版本
- `DELETED_BIT`: 1byte, **记录是否被删除的flag标记位**. 记录被删除并不代表真的删除，而是删除flag变了。
  
  > 也就是说，当删除一条记录时，并非直接去聚簇索引中将该记录行删除，因为记录在聚簇索引中本身就是按照主键有序排列的，如果真的直接删除聚簇索引中的记录行，那么相当于顺序表删除，时间复杂度很高，所以删除时只是将flag字段修改。等持久化落盘时才会根据flag字段进行进一步修改记录结构

### undo log - undo日志

> MySQL 将来是以服务进程的方式，在内存中运行的。我们之前所讲的所有机制：索引，事务，隔离性，日志等，都是在内存中实现的，即在MySQL内存的相关缓冲区`buffer pool`中，保存相关数据，完成各种判断操作。然后在合适的时候，将相关数据刷新到磁盘当中的。
> 所以，我们这里理解undo log，可以简单理解成 **MySQL 中的一段内存缓冲区**，用来保存日志数据的就行。（undo log为buffer pool的一部分）

Undo log 的用途

1. 保证事务的**原子性**，支持事务进行rollback回滚

2. 配合read view 实现MVCC(读写并发无锁化)：在MVCC中，快照读通过读取undo log的历史版本数据从而实现读写并发。

由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo log。

插入更新删除操作都会记录对应的undo log

> **基于记录四个隐藏列字段+undo log简单模拟MVCC-多版本并发控制**
>
> 现在有一个事务10，对student表中记录进行修改(update)：将name(张三)改成name(李四)。
>
> 1. 事务10，因为要修改，所以要先给该记录加行锁。
> 2. 修改前，先将该行记录拷贝到undo log中，所以，undo log中就有了一行副本数据-历史记录。
> 3. 所以现在 MySQL 中有两行同样的记录。现在修改原始记录中的name，改成 '李四'。并且修改原始记录的隐藏字段`DB_TRX_ID`为当前事务10的ID（我们默认从10开始，之后递增）而原始记录的回滚指针`DB_ROLL_PTR`列，里面写入`undo log`中副本数据的地址，从而指向副本记录，表示我的上一个版本就是它。
> 4. 事务10提交，释放锁。
>
> 备注：此时，最新的记录是’李四‘那条记录。 
>
> 现在又有一个事务11，对student表中记录进行修改(update)：将age(28)改成age(38)。
>
> 1. 事务11，因为也要修改，所以要先给该记录加行锁。
> 2. 修改前，先将该行记录拷贝到undo log中，所以，undo log中就又有了一行副本数据。此时，新的副本，我们采用头插方式，插入undo log。
> 3. 现在修改聚簇索引中记录的age，改成38。并且修改原始记录的隐藏字段`DB_TRX_ID`为当前事务11的 ID。而原始记录的回滚指针 `DB_ROLL_PTR` 列，里面写入undo log中副本数据的地址，从而指向副本记录，即表示我的上一个版本就是它。 
> 4. 事务11提交，释放锁。
>
> 最终，这两次update所形成的最终结果如图：聚簇索引中记录的是最新的记录，而历史记录在undo log中，它们通过`DB_ROLL_PTR`字段相连，形成版本链。
>
> ![image-20230829143337929](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230829143337929.png)
>
> 这样，我们就有了一个基于链表结构的记录的历史版本链。所谓的回滚，无非就是用历史数据，覆盖当前数据。 上面的一个一个版本，我们可以称之为一个一个的快照。

### Read View

在select进行快照读时, 应该读取记录的众多版本中的哪个版本? 用到的就是Read View

**Read View是用来配合快照读进行可见性判断的。 即当某个事务执行快照读的时候, 创建一个 Read View 读视图，通过它来判断当前事务能够看到记录版本链中哪个版本的数据**  (在 MySQL 源码中,就是一个类)

> 我们在实际读取数据的历史版本链的时候，是能获取到每一个版本的记录对应的事务ID的，即：记录的`DB_TRX_ID` 。
>
> 所以现在的问题就是，根据当前快照读的`ReadView`和版本链中的某一个记录的`DB_TRX_ID`判断当前快照读应不应该读到这个版本的记录。本质就是进行可见性的判断
>
> 进行快照读的select时，会生成ReadView，然后会对记录的版本链进行遍历判断，当找到符合条件的记录时，即终止。
>
> ```c++
> class ReadView {
> 	// 省略...
> private:
> 	/** 高水位，大于等于这个ID的事务均不可见*/
> 	trx_id_t m_low_limit_id;  // ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1（注意，这里并非一定是m_ids中的最大ID+1）
>     /** 低水位：小于这个ID的事务均可见 */
> 	trx_id_t m_up_limit_id;    // 记录m_ids列表中最小的事务ID
> 	/** 创建该 Read View 的事务ID*/
> 	trx_id_t m_creator_trx_id;  // 创建该ReadView的事务ID
> 	/** 创建视图时的活跃事务id列表*/ //未提交事务ID列表，用来维护Read View生成时刻，系统正活跃的事务ID
> 	ids_t m_ids;
>     
> 	/** 配合purge，标识该视图不需要小于m_low_limit_no的UNDO LOG，
> 	* 如果其他视图也不需要，则可以删除小于m_low_limit_no的UNDO LOG*/
> 	trx_id_t m_low_limit_no;
> 	/** 标记视图是否被关闭*/
> 	bool m_closed;
> 	// 省略...
> };
> ```
>
> ![image-20230829151908796](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230829151908796.png)
>
> 1. 若creator_trx_id == DB_TRX_ID则表示该版本的记录就是此事务修改的，则可见。或者当DB_TRX_ID < up_limit_id时，表示在进行快照读并形成ReadView时，该记录对应的事务已经commit了，则可见
>
> 2. 若DB_TRX_ID >= low_limit_id，则表示这个版本的记录对应的事务是在形成ReadView快照之后才出现的，则不可见
>
> 3. 剩余可能性: 1. 在m_ids中 2. 不在m_ids中。
>
>    - 若在m_ids中，表示在快照读形成读视图ReadView时，该版本的记录对应的事务与此当前事务正在并发执行（这个事务还在活跃，还没有Commit, 则不可见
>
>    - 若不在m_ids中，表示对应事务已经commit了（这个事务在Read View生成之前就已经Commit了），则可见
>
> **简单来说，只要形成读视图时，记录对应的DB_TRX_ID事务已经commit了，则可见。**
>
> <img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230829154152325.png" alt="image-20230829154152325" style="zoom:67%;" />
>
> > 上图为利用快照读时形成的ReadView对版本链中的记录进行可见性判断的函数，此函数为ReadView的成员函数，所以可以直接访问数据成员。其实就是对版本链中的记录进行遍历判断，若返回为true则表示可见，并终止遍历。

> 模拟MVCC整体流程
>
> <img src="https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230829160121465.png" alt="image-20230829160121465" style="zoom:50%;" />
>
> ![image-20230829160152883](https://cdn.jsdelivr.net/gh/DaysOfExperience/blogImage@main/img/image-20230829160152883.png)
>
> 事务4：修改name(张三) 变成name(李四) 
> 当 事务2 对某行数据执行了 快照读 ，数据库为该行数据生成一个 Read View 读视图
>
> ```mysql
> //事务2此次快照读的 Read View
> m_ids;       // 1,3
> up_limit_id; // 1
> low_limit_id; // 4 + 1 = 5，原因：ReadView生成时刻，系统尚未分配的下一个事务ID
> creator_trx_id // 2
> ```
>
> 我们的事务2在快照读该行记录的时候，就会拿该行记录的 DB_TRX_ID 去跟ReadView中的up_limit_id,low_limit_id和活跃事务ID列表(trx_list) 进行比较，判断结果为当前事务2能看到该记录的版本。
>
> ```mysql
> -- 事务2的 Read View
> m_ids; // 1,3
> up_limit_id; // 1
> low_limit_id; // 4 + 1 = 5，原因：ReadView生成时刻，系统尚未分配的下一个事务ID
> creator_trx_id // 2
> -- 事务4提交的记录对应的事务ID
> DB_TRX_ID=4
> -- 比较步骤
> DB_TRX_ID（4）< up_limit_id（1） ? 不小于，下一步
> DB_TRX_ID（4）>= low_limit_id(5) ? 不大于，下一步
> m_ids.contains(DB_TRX_ID) ? 不包含，说明，事务4不在当前的活跃事务中。
> -- 结论
> 故，该版本的记录对事务2在快照读时是可见的。
> 所以事务2能读到的最新版本的数据记录是事务4所提交的版本，而事务4提交的版本也是全局角度上最新的版本。
> ```

上方介绍了MVCC的实现原理的三个重要组成部分，三个隐藏列字段+undo log完成版本控制，而ReadView为当事务进行快照读时生成该视图，然后对版本链中的记录逐个进行可见性判断。

但是需要注意的是，其实MVCC的介绍过程中，并没有提及具体的隔离级别。那么，具体的RR和RC是如何通过MVCC实现的呢？

# RR vs RC

首先先来一个测试，体验一下当前读和快照读在RR级别下的区别，以及稍微进一步地理解一下RR隔离级别。

测试环境：RR隔离级别

测试

----

测试1

| 事务A操作                                      | 事务A操作描述 | 事务B操作                                 | 事务B操作描述                                     |
| ---------------------------------------------- | ------------- | ----------------------------------------- | ------------------------------------------------- |
| begin                                          | 开启事务      | begin                                     | 开启事务                                          |
| select * from account;                         | 快照读查询    | select * from account;                    | 快照读查询                                        |
| update account set name = '里斯' where id = 1; | 更新          |                                           |                                                   |
| commit                                         | 提交事务      |                                           |                                                   |
|                                                |               | select * from account;                    | select 快照读 ,没有读取到事务A的更新              |
|                                                |               | select * from account lock in share mode; | select lock in share mode当前读 , 读到事务A的更新 |

测试2

| 事务A操作                                      | 事务A操作描述 | 事务B操作                                 | 事务B操作描述                                     |
| ---------------------------------------------- | ------------- | ----------------------------------------- | ------------------------------------------------- |
| begin                                          | 开启事务      | begin                                     | 开启事务                                          |
| select * from account;                         | 快照读查询    |                                           |                                                   |
| update account set name = '里斯' where id = 1; | 更新          |                                           |                                                   |
| commit                                         | 提交事务      |                                           |                                                   |
|                                                |               | select * from account;                    | select 快照读 ,读取到事务A的更新                  |
|                                                |               | select * from account lock in share mode; | select lock in share mode当前读 , 读到事务A的更新 |
|                                                |               | select * from account;                    | select 快照读 ,读取到事务A的更新                  |

现象：测试2中，我们发现事务B在事务A commit之后，再进行快照读时是读取到了事务A的更新的，其实这个有点不符合我们之前的意料。但是这依旧是符合可重复读这个要求的。

用例1与用例2差别就是事务B第一次快照读的时机，是事务A commit前还是后。

结论：

**RR隔离级别下, 事务中快照读的结果 非常依赖 该事务 首次出现快照读 的地方，即某个事务中首次出现快照读的时机，决定了该事务后续快照读的结果**

### RR

- 在**RR级别下**的某个事务的对某条记录的**第一次快照读会创建一个快照即Read View**, 将当前系统活跃的其他事务记录起来。**此后在该事务进行的所有快照读都使用的是同一个Read View, 所以对其他事务的commit的修改不可见；**

### RC

- 而在**RC级别下**的事务中，**每次快照读都会生成一个新的Read View**

> 正是RC每次快照读，都会形成Read View，所以，RC才会有不可重复读问题。正是RR每次快照读都是使用第一次快照读生成的ReadView，所以RR才可重复读。
>
> 之前说MVCC使读写并发无锁化，而严格来说, MVCC解决的是快照读与写之间的并发问题。而当前读与写的并发问题是通过锁来解决的。
>
> 总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案

---

读读并发 不讨论  写写并发  不讨论

所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：

- MVCC + 悲观锁: MVCC解决读写冲突，悲观锁解决写写冲突
- MVCC + 乐观锁: MVCC解决读写冲突，乐观锁解决写写冲突
